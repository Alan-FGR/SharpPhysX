// Generated by minBND 5.1.81.43 - Â© github.com/Alan-FGR
//Unit PxRigidBodyExt
using System;
using System.Runtime.InteropServices;

public static unsafe partial class physx {
    public static unsafe partial class PxRigidBodyExt {
    [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern bool bool_physx_PxRigidBodyExt_updateMassAndInertia_physx_PxRigidBodyPtr_float_uint_physx_PxVec3_bool_(physx.PxRigidBodyPtr pvk_body, float* pvk_shapeDensities, uint pvk_shapeDensityCount, physx.PxVec3* pvk_massLocalPose, bool pvk_includeNonSimShapes);
        
        public static bool updateMassAndInertia(physx.PxRigidBodyPtr body, float* shapeDensities, uint shapeDensityCount, physx.PxVec3* massLocalPose, bool includeNonSimShapes=false) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float* pvk_in_shapeDensities = shapeDensities;
            uint pvk_in_shapeDensityCount = shapeDensityCount;
            physx.PxVec3* pvk_in_massLocalPose = massLocalPose;
            bool pvk_in_includeNonSimShapes = includeNonSimShapes;
            return bool_physx_PxRigidBodyExt_updateMassAndInertia_physx_PxRigidBodyPtr_float_uint_physx_PxVec3_bool_(pvk_in_body, pvk_in_shapeDensities, pvk_in_shapeDensityCount, pvk_in_massLocalPose, pvk_in_includeNonSimShapes);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern bool bool_physx_PxRigidBodyExt_updateMassAndInertia_physx_PxRigidBodyPtr_float_physx_PxVec3_bool_(physx.PxRigidBodyPtr pvk_body, float pvk_density, physx.PxVec3* pvk_massLocalPose, bool pvk_includeNonSimShapes);
        
        public static bool updateMassAndInertia(physx.PxRigidBodyPtr body, float density, physx.PxVec3* massLocalPose, bool includeNonSimShapes=false) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float pvk_in_density = density;
            physx.PxVec3* pvk_in_massLocalPose = massLocalPose;
            bool pvk_in_includeNonSimShapes = includeNonSimShapes;
            return bool_physx_PxRigidBodyExt_updateMassAndInertia_physx_PxRigidBodyPtr_float_physx_PxVec3_bool_(pvk_in_body, pvk_in_density, pvk_in_massLocalPose, pvk_in_includeNonSimShapes);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern bool bool_physx_PxRigidBodyExt_setMassAndUpdateInertia_physx_PxRigidBodyPtr_float_uint_physx_PxVec3_bool_(physx.PxRigidBodyPtr pvk_body, float* pvk_shapeMasses, uint pvk_shapeMassCount, physx.PxVec3* pvk_massLocalPose, bool pvk_includeNonSimShapes);
        
        public static bool setMassAndUpdateInertia(physx.PxRigidBodyPtr body, float* shapeMasses, uint shapeMassCount, physx.PxVec3* massLocalPose, bool includeNonSimShapes=false) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float* pvk_in_shapeMasses = shapeMasses;
            uint pvk_in_shapeMassCount = shapeMassCount;
            physx.PxVec3* pvk_in_massLocalPose = massLocalPose;
            bool pvk_in_includeNonSimShapes = includeNonSimShapes;
            return bool_physx_PxRigidBodyExt_setMassAndUpdateInertia_physx_PxRigidBodyPtr_float_uint_physx_PxVec3_bool_(pvk_in_body, pvk_in_shapeMasses, pvk_in_shapeMassCount, pvk_in_massLocalPose, pvk_in_includeNonSimShapes);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern bool bool_physx_PxRigidBodyExt_setMassAndUpdateInertia_physx_PxRigidBodyPtr_float_physx_PxVec3_bool_(physx.PxRigidBodyPtr pvk_body, float pvk_mass, physx.PxVec3* pvk_massLocalPose, bool pvk_includeNonSimShapes);
        
        public static bool setMassAndUpdateInertia(physx.PxRigidBodyPtr body, float mass, physx.PxVec3* massLocalPose, bool includeNonSimShapes=false) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float pvk_in_mass = mass;
            physx.PxVec3* pvk_in_massLocalPose = massLocalPose;
            bool pvk_in_includeNonSimShapes = includeNonSimShapes;
            return bool_physx_PxRigidBodyExt_setMassAndUpdateInertia_physx_PxRigidBodyPtr_float_physx_PxVec3_bool_(pvk_in_body, pvk_in_mass, pvk_in_massLocalPose, pvk_in_includeNonSimShapes);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern physx.PxMassPropertiesPtr physx_PxMassPropertiesPtr_physx_PxRigidBodyExt_computeMassPropertiesFromShapes_physx_PxShapePtr_uint_(physx.PxShapePtr* pvk_shapes, uint pvk_shapeCount);
        
        public static physx.PxMassPropertiesPtr computeMassPropertiesFromShapes_New(physx.PxShapePtr* shapes, uint shapeCount) {
            physx.PxShapePtr* pvk_in_shapes = shapes;
            uint pvk_in_shapeCount = shapeCount;
            return physx_PxMassPropertiesPtr_physx_PxRigidBodyExt_computeMassPropertiesFromShapes_physx_PxShapePtr_uint_(pvk_in_shapes, pvk_in_shapeCount);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void void_physx_PxRigidBodyExt_addForceAtPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxForceModeEnum_bool_(physx.PxRigidBodyPtr pvk_body, physx.PxVec3* pvk_force, physx.PxVec3* pvk_pos, physx.PxForceModeEnum pvk_mode, bool pvk_wakeup);
        
        public static void addForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            physx.PxForceModeEnum pvk_in_mode = mode;
            bool pvk_in_wakeup = wakeup;
            void_physx_PxRigidBodyExt_addForceAtPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxForceModeEnum_bool_(pvk_in_body, pvk_in_force, pvk_in_pos, pvk_in_mode, pvk_in_wakeup);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void void_physx_PxRigidBodyExt_addForceAtLocalPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxForceModeEnum_bool_(physx.PxRigidBodyPtr pvk_body, physx.PxVec3* pvk_force, physx.PxVec3* pvk_pos, physx.PxForceModeEnum pvk_mode, bool pvk_wakeup);
        
        public static void addForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            physx.PxForceModeEnum pvk_in_mode = mode;
            bool pvk_in_wakeup = wakeup;
            void_physx_PxRigidBodyExt_addForceAtLocalPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxForceModeEnum_bool_(pvk_in_body, pvk_in_force, pvk_in_pos, pvk_in_mode, pvk_in_wakeup);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void void_physx_PxRigidBodyExt_addLocalForceAtPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxForceModeEnum_bool_(physx.PxRigidBodyPtr pvk_body, physx.PxVec3* pvk_force, physx.PxVec3* pvk_pos, physx.PxForceModeEnum pvk_mode, bool pvk_wakeup);
        
        public static void addLocalForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            physx.PxForceModeEnum pvk_in_mode = mode;
            bool pvk_in_wakeup = wakeup;
            void_physx_PxRigidBodyExt_addLocalForceAtPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxForceModeEnum_bool_(pvk_in_body, pvk_in_force, pvk_in_pos, pvk_in_mode, pvk_in_wakeup);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void void_physx_PxRigidBodyExt_addLocalForceAtLocalPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxForceModeEnum_bool_(physx.PxRigidBodyPtr pvk_body, physx.PxVec3* pvk_force, physx.PxVec3* pvk_pos, physx.PxForceModeEnum pvk_mode, bool pvk_wakeup);
        
        public static void addLocalForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            physx.PxForceModeEnum pvk_in_mode = mode;
            bool pvk_in_wakeup = wakeup;
            void_physx_PxRigidBodyExt_addLocalForceAtLocalPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxForceModeEnum_bool_(pvk_in_body, pvk_in_force, pvk_in_pos, pvk_in_mode, pvk_in_wakeup);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void physx_PxVec3_physx_PxRigidBodyExt_getVelocityAtPos_physx_PxRigidBodyPtr_physx_PxVec3_(physx.PxVec3* RetRef, physx.PxRigidBodyPtr pvk_body, physx.PxVec3* pvk_pos);
        
        public static physx.PxVec3 getVelocityAtPos(physx.PxRigidBodyPtr body, physx.PxVec3* pos) {
            physx.PxVec3 RetRef;
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_pos = pos;
            physx_PxVec3_physx_PxRigidBodyExt_getVelocityAtPos_physx_PxRigidBodyPtr_physx_PxVec3_(&RetRef, pvk_in_body, pvk_in_pos);
            return RetRef;
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void physx_PxVec3_physx_PxRigidBodyExt_getLocalVelocityAtLocalPos_physx_PxRigidBodyPtr_physx_PxVec3_(physx.PxVec3* RetRef, physx.PxRigidBodyPtr pvk_body, physx.PxVec3* pvk_pos);
        
        public static physx.PxVec3 getLocalVelocityAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3* pos) {
            physx.PxVec3 RetRef;
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_pos = pos;
            physx_PxVec3_physx_PxRigidBodyExt_getLocalVelocityAtLocalPos_physx_PxRigidBodyPtr_physx_PxVec3_(&RetRef, pvk_in_body, pvk_in_pos);
            return RetRef;
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void physx_PxVec3_physx_PxRigidBodyExt_getVelocityAtOffset_physx_PxRigidBodyPtr_physx_PxVec3_(physx.PxVec3* RetRef, physx.PxRigidBodyPtr pvk_body, physx.PxVec3* pvk_pos);
        
        public static physx.PxVec3 getVelocityAtOffset(physx.PxRigidBodyPtr body, physx.PxVec3* pos) {
            physx.PxVec3 RetRef;
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_pos = pos;
            physx_PxVec3_physx_PxRigidBodyExt_getVelocityAtOffset_physx_PxRigidBodyPtr_physx_PxVec3_(&RetRef, pvk_in_body, pvk_in_pos);
            return RetRef;
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern bool bool_physx_PxRigidBodyExt_linearSweepSingle_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_physx_PxQueryFilterDataPtr_physx_PxQueryFilterCallbackPtr_physx_PxQueryCachePtr_float_C_C(physx.PxRigidBodyPtr pvk_body, physx.PxScenePtr pvk_scene, physx.PxVec3* pvk_unitDir, float pvk_distance, PxHitFlagsPtr pvk_outputFlags, physx.PxSweepHitPtr pvk_closestHit, uint* pvk_shapeIndex, physx.PxQueryFilterDataPtr pvk_filterData, physx.PxQueryFilterCallbackPtr pvk_filterCall, physx.PxQueryCachePtr pvk_cache, float pvk_inflation);
        
        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr), float inflation=0f) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            PxHitFlagsPtr pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_closestHit = closestHit;
            uint* pvk_in_shapeIndex = shapeIndex;
            physx.PxQueryFilterDataPtr pvk_in_filterData = filterData;
            physx.PxQueryFilterCallbackPtr pvk_in_filterCall = filterCall;
            physx.PxQueryCachePtr pvk_in_cache = cache;
            float pvk_in_inflation = inflation;
            return bool_physx_PxRigidBodyExt_linearSweepSingle_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_physx_PxQueryFilterDataPtr_physx_PxQueryFilterCallbackPtr_physx_PxQueryCachePtr_float_C_C(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_closestHit, pvk_in_shapeIndex, pvk_in_filterData, pvk_in_filterCall, pvk_in_cache, pvk_in_inflation);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern uint uint_physx_PxRigidBodyExt_linearSweepMultiple_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_uint_physx_PxSweepHitPtr_int_bool_physx_PxQueryFilterDataPtr_physx_PxQueryFilterCallbackPtr_physx_PxQueryCachePtr_float_C_C(physx.PxRigidBodyPtr pvk_body, physx.PxScenePtr pvk_scene, physx.PxVec3* pvk_unitDir, float pvk_distance, PxHitFlagsPtr pvk_outputFlags, physx.PxSweepHitPtr pvk_touchHitBuffer, uint* pvk_touchHitShapeIndices, uint pvk_touchHitBufferSize, physx.PxSweepHitPtr pvk_block, int* pvk_blockingShapeIndex, bool* pvk_overflow, physx.PxQueryFilterDataPtr pvk_filterData, physx.PxQueryFilterCallbackPtr pvk_filterCall, physx.PxQueryCachePtr pvk_cache, float pvk_inflation);
        
        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr), float inflation=0f) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            PxHitFlagsPtr pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_touchHitBuffer = touchHitBuffer;
            uint* pvk_in_touchHitShapeIndices = touchHitShapeIndices;
            uint pvk_in_touchHitBufferSize = touchHitBufferSize;
            physx.PxSweepHitPtr pvk_in_block = block;
            int* pvk_in_blockingShapeIndex = blockingShapeIndex;
            bool* pvk_in_overflow = overflow;
            physx.PxQueryFilterDataPtr pvk_in_filterData = filterData;
            physx.PxQueryFilterCallbackPtr pvk_in_filterCall = filterCall;
            physx.PxQueryCachePtr pvk_in_cache = cache;
            float pvk_in_inflation = inflation;
            return uint_physx_PxRigidBodyExt_linearSweepMultiple_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_uint_physx_PxSweepHitPtr_int_bool_physx_PxQueryFilterDataPtr_physx_PxQueryFilterCallbackPtr_physx_PxQueryCachePtr_float_C_C(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_touchHitBuffer, pvk_in_touchHitShapeIndices, pvk_in_touchHitBufferSize, pvk_in_block, pvk_in_blockingShapeIndex, pvk_in_overflow, pvk_in_filterData, pvk_in_filterCall, pvk_in_cache, pvk_in_inflation);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void void_physx_PxRigidBodyExt_computeVelocityDeltaFromImpulse_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxVec3_physx_PxVec3_(physx.PxRigidBodyPtr pvk_body, physx.PxVec3* pvk_impulsiveForce, physx.PxVec3* pvk_impulsiveTorque, physx.PxVec3* pvk_deltaLinearVelocity, physx.PxVec3* pvk_deltaAngularVelocity);
        
        public static void computeVelocityDeltaFromImpulse(physx.PxRigidBodyPtr body, physx.PxVec3* impulsiveForce, physx.PxVec3* impulsiveTorque, physx.PxVec3* deltaLinearVelocity, physx.PxVec3* deltaAngularVelocity) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_impulsiveForce = impulsiveForce;
            physx.PxVec3* pvk_in_impulsiveTorque = impulsiveTorque;
            physx.PxVec3* pvk_in_deltaLinearVelocity = deltaLinearVelocity;
            physx.PxVec3* pvk_in_deltaAngularVelocity = deltaAngularVelocity;
            void_physx_PxRigidBodyExt_computeVelocityDeltaFromImpulse_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxVec3_physx_PxVec3_(pvk_in_body, pvk_in_impulsiveForce, pvk_in_impulsiveTorque, pvk_in_deltaLinearVelocity, pvk_in_deltaAngularVelocity);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void void_physx_PxRigidBodyExt_computeVelocityDeltaFromImpulse_physx_PxRigidBodyPtr_physx_PxTransform_physx_PxVec3_physx_PxVec3_float_float_physx_PxVec3_physx_PxVec3_CC_(physx.PxRigidBodyPtr pvk_body, physx.PxTransform* pvk_globalPose, physx.PxVec3* pvk_point, physx.PxVec3* pvk_impulse, float pvk_invMassScale, float pvk_invInertiaScale, physx.PxVec3* pvk_deltaLinearVelocity, physx.PxVec3* pvk_deltaAngularVelocity);
        
        public static void computeVelocityDeltaFromImpulse(physx.PxRigidBodyPtr body, physx.PxTransform* globalPose, physx.PxVec3* point, physx.PxVec3* impulse, float invMassScale, float invInertiaScale, physx.PxVec3* deltaLinearVelocity, physx.PxVec3* deltaAngularVelocity) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxTransform* pvk_in_globalPose = globalPose;
            physx.PxVec3* pvk_in_point = point;
            physx.PxVec3* pvk_in_impulse = impulse;
            float pvk_in_invMassScale = invMassScale;
            float pvk_in_invInertiaScale = invInertiaScale;
            physx.PxVec3* pvk_in_deltaLinearVelocity = deltaLinearVelocity;
            physx.PxVec3* pvk_in_deltaAngularVelocity = deltaAngularVelocity;
            void_physx_PxRigidBodyExt_computeVelocityDeltaFromImpulse_physx_PxRigidBodyPtr_physx_PxTransform_physx_PxVec3_physx_PxVec3_float_float_physx_PxVec3_physx_PxVec3_CC_(pvk_in_body, pvk_in_globalPose, pvk_in_point, pvk_in_impulse, pvk_in_invMassScale, pvk_in_invInertiaScale, pvk_in_deltaLinearVelocity, pvk_in_deltaAngularVelocity);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void void_physx_PxRigidBodyExt_computeLinearAngularImpulse_physx_PxRigidBodyPtr_physx_PxTransform_physx_PxVec3_physx_PxVec3_float_float_physx_PxVec3_physx_PxVec3_CC_(physx.PxRigidBodyPtr pvk_body, physx.PxTransform* pvk_globalPose, physx.PxVec3* pvk_point, physx.PxVec3* pvk_impulse, float pvk_invMassScale, float pvk_invInertiaScale, physx.PxVec3* pvk_linearImpulse, physx.PxVec3* pvk_angularImpulse);
        
        public static void computeLinearAngularImpulse(physx.PxRigidBodyPtr body, physx.PxTransform* globalPose, physx.PxVec3* point, physx.PxVec3* impulse, float invMassScale, float invInertiaScale, physx.PxVec3* linearImpulse, physx.PxVec3* angularImpulse) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxTransform* pvk_in_globalPose = globalPose;
            physx.PxVec3* pvk_in_point = point;
            physx.PxVec3* pvk_in_impulse = impulse;
            float pvk_in_invMassScale = invMassScale;
            float pvk_in_invInertiaScale = invInertiaScale;
            physx.PxVec3* pvk_in_linearImpulse = linearImpulse;
            physx.PxVec3* pvk_in_angularImpulse = angularImpulse;
            void_physx_PxRigidBodyExt_computeLinearAngularImpulse_physx_PxRigidBodyPtr_physx_PxTransform_physx_PxVec3_physx_PxVec3_float_float_physx_PxVec3_physx_PxVec3_CC_(pvk_in_body, pvk_in_globalPose, pvk_in_point, pvk_in_impulse, pvk_in_invMassScale, pvk_in_invInertiaScale, pvk_in_linearImpulse, pvk_in_angularImpulse);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern bool bool_physx_PxRigidBodyExt_updateMassAndInertia_physx_PxRigidBodyPtr_float_uint_(physx.PxRigidBodyPtr pvk_body, float* pvk_shapeDensities, uint pvk_shapeDensityCount);
        
        public static bool updateMassAndInertia(physx.PxRigidBodyPtr body, float* shapeDensities, uint shapeDensityCount) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float* pvk_in_shapeDensities = shapeDensities;
            uint pvk_in_shapeDensityCount = shapeDensityCount;
            return bool_physx_PxRigidBodyExt_updateMassAndInertia_physx_PxRigidBodyPtr_float_uint_(pvk_in_body, pvk_in_shapeDensities, pvk_in_shapeDensityCount);
        }
        
        public static bool updateMassAndInertia(physx.PxRigidBodyPtr body, float* shapeDensities, uint shapeDensityCount, physx.PxVec3 massLocalPose) {
            return updateMassAndInertia(body, shapeDensities, shapeDensityCount, &massLocalPose);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern bool bool_physx_PxRigidBodyExt_updateMassAndInertia_physx_PxRigidBodyPtr_float_uint_physx_PxVec3_(physx.PxRigidBodyPtr pvk_body, float* pvk_shapeDensities, uint pvk_shapeDensityCount, physx.PxVec3* pvk_massLocalPose);
        
        public static bool updateMassAndInertia(physx.PxRigidBodyPtr body, float* shapeDensities, uint shapeDensityCount, physx.PxVec3* massLocalPose) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float* pvk_in_shapeDensities = shapeDensities;
            uint pvk_in_shapeDensityCount = shapeDensityCount;
            physx.PxVec3* pvk_in_massLocalPose = massLocalPose;
            return bool_physx_PxRigidBodyExt_updateMassAndInertia_physx_PxRigidBodyPtr_float_uint_physx_PxVec3_(pvk_in_body, pvk_in_shapeDensities, pvk_in_shapeDensityCount, pvk_in_massLocalPose);
        }
        
        public static bool updateMassAndInertia(physx.PxRigidBodyPtr body, float* shapeDensities, uint shapeDensityCount, physx.PxVec3 massLocalPose, bool includeNonSimShapes=false) {
            return updateMassAndInertia(body, shapeDensities, shapeDensityCount, &massLocalPose, includeNonSimShapes);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern bool bool_physx_PxRigidBodyExt_updateMassAndInertia_physx_PxRigidBodyPtr_float_(physx.PxRigidBodyPtr pvk_body, float pvk_density);
        
        public static bool updateMassAndInertia(physx.PxRigidBodyPtr body, float density) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float pvk_in_density = density;
            return bool_physx_PxRigidBodyExt_updateMassAndInertia_physx_PxRigidBodyPtr_float_(pvk_in_body, pvk_in_density);
        }
        
        public static bool updateMassAndInertia(physx.PxRigidBodyPtr body, float density, physx.PxVec3 massLocalPose) {
            return updateMassAndInertia(body, density, &massLocalPose);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern bool bool_physx_PxRigidBodyExt_updateMassAndInertia_physx_PxRigidBodyPtr_float_physx_PxVec3_(physx.PxRigidBodyPtr pvk_body, float pvk_density, physx.PxVec3* pvk_massLocalPose);
        
        public static bool updateMassAndInertia(physx.PxRigidBodyPtr body, float density, physx.PxVec3* massLocalPose) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float pvk_in_density = density;
            physx.PxVec3* pvk_in_massLocalPose = massLocalPose;
            return bool_physx_PxRigidBodyExt_updateMassAndInertia_physx_PxRigidBodyPtr_float_physx_PxVec3_(pvk_in_body, pvk_in_density, pvk_in_massLocalPose);
        }
        
        public static bool updateMassAndInertia(physx.PxRigidBodyPtr body, float density, physx.PxVec3 massLocalPose, bool includeNonSimShapes=false) {
            return updateMassAndInertia(body, density, &massLocalPose, includeNonSimShapes);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern bool bool_physx_PxRigidBodyExt_setMassAndUpdateInertia_physx_PxRigidBodyPtr_float_uint_(physx.PxRigidBodyPtr pvk_body, float* pvk_shapeMasses, uint pvk_shapeMassCount);
        
        public static bool setMassAndUpdateInertia(physx.PxRigidBodyPtr body, float* shapeMasses, uint shapeMassCount) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float* pvk_in_shapeMasses = shapeMasses;
            uint pvk_in_shapeMassCount = shapeMassCount;
            return bool_physx_PxRigidBodyExt_setMassAndUpdateInertia_physx_PxRigidBodyPtr_float_uint_(pvk_in_body, pvk_in_shapeMasses, pvk_in_shapeMassCount);
        }
        
        public static bool setMassAndUpdateInertia(physx.PxRigidBodyPtr body, float* shapeMasses, uint shapeMassCount, physx.PxVec3 massLocalPose) {
            return setMassAndUpdateInertia(body, shapeMasses, shapeMassCount, &massLocalPose);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern bool bool_physx_PxRigidBodyExt_setMassAndUpdateInertia_physx_PxRigidBodyPtr_float_uint_physx_PxVec3_(physx.PxRigidBodyPtr pvk_body, float* pvk_shapeMasses, uint pvk_shapeMassCount, physx.PxVec3* pvk_massLocalPose);
        
        public static bool setMassAndUpdateInertia(physx.PxRigidBodyPtr body, float* shapeMasses, uint shapeMassCount, physx.PxVec3* massLocalPose) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float* pvk_in_shapeMasses = shapeMasses;
            uint pvk_in_shapeMassCount = shapeMassCount;
            physx.PxVec3* pvk_in_massLocalPose = massLocalPose;
            return bool_physx_PxRigidBodyExt_setMassAndUpdateInertia_physx_PxRigidBodyPtr_float_uint_physx_PxVec3_(pvk_in_body, pvk_in_shapeMasses, pvk_in_shapeMassCount, pvk_in_massLocalPose);
        }
        
        public static bool setMassAndUpdateInertia(physx.PxRigidBodyPtr body, float* shapeMasses, uint shapeMassCount, physx.PxVec3 massLocalPose, bool includeNonSimShapes=false) {
            return setMassAndUpdateInertia(body, shapeMasses, shapeMassCount, &massLocalPose, includeNonSimShapes);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern bool bool_physx_PxRigidBodyExt_setMassAndUpdateInertia_physx_PxRigidBodyPtr_float_(physx.PxRigidBodyPtr pvk_body, float pvk_mass);
        
        public static bool setMassAndUpdateInertia(physx.PxRigidBodyPtr body, float mass) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float pvk_in_mass = mass;
            return bool_physx_PxRigidBodyExt_setMassAndUpdateInertia_physx_PxRigidBodyPtr_float_(pvk_in_body, pvk_in_mass);
        }
        
        public static bool setMassAndUpdateInertia(physx.PxRigidBodyPtr body, float mass, physx.PxVec3 massLocalPose) {
            return setMassAndUpdateInertia(body, mass, &massLocalPose);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern bool bool_physx_PxRigidBodyExt_setMassAndUpdateInertia_physx_PxRigidBodyPtr_float_physx_PxVec3_(physx.PxRigidBodyPtr pvk_body, float pvk_mass, physx.PxVec3* pvk_massLocalPose);
        
        public static bool setMassAndUpdateInertia(physx.PxRigidBodyPtr body, float mass, physx.PxVec3* massLocalPose) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float pvk_in_mass = mass;
            physx.PxVec3* pvk_in_massLocalPose = massLocalPose;
            return bool_physx_PxRigidBodyExt_setMassAndUpdateInertia_physx_PxRigidBodyPtr_float_physx_PxVec3_(pvk_in_body, pvk_in_mass, pvk_in_massLocalPose);
        }
        
        public static bool setMassAndUpdateInertia(physx.PxRigidBodyPtr body, float mass, physx.PxVec3 massLocalPose, bool includeNonSimShapes=false) {
            return setMassAndUpdateInertia(body, mass, &massLocalPose, includeNonSimShapes);
        }
        
        public static void addForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos) {
            addForceAtPos(body, &force, &pos);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void void_physx_PxRigidBodyExt_addForceAtPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_(physx.PxRigidBodyPtr pvk_body, physx.PxVec3* pvk_force, physx.PxVec3* pvk_pos);
        
        public static void addForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            void_physx_PxRigidBodyExt_addForceAtPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_(pvk_in_body, pvk_in_force, pvk_in_pos);
        }
        
        public static void addForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos, physx.PxForceModeEnum mode) {
            addForceAtPos(body, &force, &pos, mode);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void void_physx_PxRigidBodyExt_addForceAtPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxForceModeEnum_(physx.PxRigidBodyPtr pvk_body, physx.PxVec3* pvk_force, physx.PxVec3* pvk_pos, physx.PxForceModeEnum pvk_mode);
        
        public static void addForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos, physx.PxForceModeEnum mode) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            physx.PxForceModeEnum pvk_in_mode = mode;
            void_physx_PxRigidBodyExt_addForceAtPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxForceModeEnum_(pvk_in_body, pvk_in_force, pvk_in_pos, pvk_in_mode);
        }
        
        public static void addForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            addForceAtPos(body, &force, &pos, mode, wakeup);
        }
        
        public static void addForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos) {
            addForceAtLocalPos(body, &force, &pos);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void void_physx_PxRigidBodyExt_addForceAtLocalPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_(physx.PxRigidBodyPtr pvk_body, physx.PxVec3* pvk_force, physx.PxVec3* pvk_pos);
        
        public static void addForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            void_physx_PxRigidBodyExt_addForceAtLocalPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_(pvk_in_body, pvk_in_force, pvk_in_pos);
        }
        
        public static void addForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos, physx.PxForceModeEnum mode) {
            addForceAtLocalPos(body, &force, &pos, mode);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void void_physx_PxRigidBodyExt_addForceAtLocalPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxForceModeEnum_(physx.PxRigidBodyPtr pvk_body, physx.PxVec3* pvk_force, physx.PxVec3* pvk_pos, physx.PxForceModeEnum pvk_mode);
        
        public static void addForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos, physx.PxForceModeEnum mode) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            physx.PxForceModeEnum pvk_in_mode = mode;
            void_physx_PxRigidBodyExt_addForceAtLocalPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxForceModeEnum_(pvk_in_body, pvk_in_force, pvk_in_pos, pvk_in_mode);
        }
        
        public static void addForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            addForceAtLocalPos(body, &force, &pos, mode, wakeup);
        }
        
        public static void addLocalForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos) {
            addLocalForceAtPos(body, &force, &pos);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void void_physx_PxRigidBodyExt_addLocalForceAtPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_(physx.PxRigidBodyPtr pvk_body, physx.PxVec3* pvk_force, physx.PxVec3* pvk_pos);
        
        public static void addLocalForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            void_physx_PxRigidBodyExt_addLocalForceAtPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_(pvk_in_body, pvk_in_force, pvk_in_pos);
        }
        
        public static void addLocalForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos, physx.PxForceModeEnum mode) {
            addLocalForceAtPos(body, &force, &pos, mode);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void void_physx_PxRigidBodyExt_addLocalForceAtPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxForceModeEnum_(physx.PxRigidBodyPtr pvk_body, physx.PxVec3* pvk_force, physx.PxVec3* pvk_pos, physx.PxForceModeEnum pvk_mode);
        
        public static void addLocalForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos, physx.PxForceModeEnum mode) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            physx.PxForceModeEnum pvk_in_mode = mode;
            void_physx_PxRigidBodyExt_addLocalForceAtPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxForceModeEnum_(pvk_in_body, pvk_in_force, pvk_in_pos, pvk_in_mode);
        }
        
        public static void addLocalForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            addLocalForceAtPos(body, &force, &pos, mode, wakeup);
        }
        
        public static void addLocalForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos) {
            addLocalForceAtLocalPos(body, &force, &pos);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void void_physx_PxRigidBodyExt_addLocalForceAtLocalPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_(physx.PxRigidBodyPtr pvk_body, physx.PxVec3* pvk_force, physx.PxVec3* pvk_pos);
        
        public static void addLocalForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            void_physx_PxRigidBodyExt_addLocalForceAtLocalPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_(pvk_in_body, pvk_in_force, pvk_in_pos);
        }
        
        public static void addLocalForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos, physx.PxForceModeEnum mode) {
            addLocalForceAtLocalPos(body, &force, &pos, mode);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern void void_physx_PxRigidBodyExt_addLocalForceAtLocalPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxForceModeEnum_(physx.PxRigidBodyPtr pvk_body, physx.PxVec3* pvk_force, physx.PxVec3* pvk_pos, physx.PxForceModeEnum pvk_mode);
        
        public static void addLocalForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos, physx.PxForceModeEnum mode) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            physx.PxForceModeEnum pvk_in_mode = mode;
            void_physx_PxRigidBodyExt_addLocalForceAtLocalPos_physx_PxRigidBodyPtr_physx_PxVec3_physx_PxVec3_physx_PxForceModeEnum_(pvk_in_body, pvk_in_force, pvk_in_pos, pvk_in_mode);
        }
        
        public static void addLocalForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            addLocalForceAtLocalPos(body, &force, &pos, mode, wakeup);
        }
        
        public static physx.PxVec3 getVelocityAtPos(physx.PxRigidBodyPtr body, physx.PxVec3 pos) {
            return getVelocityAtPos(body, &pos);
        }
        
        public static physx.PxVec3 getLocalVelocityAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3 pos) {
            return getLocalVelocityAtLocalPos(body, &pos);
        }
        
        public static physx.PxVec3 getVelocityAtOffset(physx.PxRigidBodyPtr body, physx.PxVec3 pos) {
            return getVelocityAtOffset(body, &pos);
        }
        
        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex) {
            return linearSweepSingle(body, scene, &unitDir, distance, outputFlags, closestHit, shapeIndex);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern bool bool_physx_PxRigidBodyExt_linearSweepSingle_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_C_(physx.PxRigidBodyPtr pvk_body, physx.PxScenePtr pvk_scene, physx.PxVec3* pvk_unitDir, float pvk_distance, PxHitFlagsPtr pvk_outputFlags, physx.PxSweepHitPtr pvk_closestHit, uint* pvk_shapeIndex);
        
        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            PxHitFlagsPtr pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_closestHit = closestHit;
            uint* pvk_in_shapeIndex = shapeIndex;
            return bool_physx_PxRigidBodyExt_linearSweepSingle_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_C_(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_closestHit, pvk_in_shapeIndex);
        }
        
        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData) {
            return linearSweepSingle(body, scene, &unitDir, distance, outputFlags, closestHit, shapeIndex, filterData);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern bool bool_physx_PxRigidBodyExt_linearSweepSingle_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_physx_PxQueryFilterDataPtr_C_(physx.PxRigidBodyPtr pvk_body, physx.PxScenePtr pvk_scene, physx.PxVec3* pvk_unitDir, float pvk_distance, PxHitFlagsPtr pvk_outputFlags, physx.PxSweepHitPtr pvk_closestHit, uint* pvk_shapeIndex, physx.PxQueryFilterDataPtr pvk_filterData);
        
        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            PxHitFlagsPtr pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_closestHit = closestHit;
            uint* pvk_in_shapeIndex = shapeIndex;
            physx.PxQueryFilterDataPtr pvk_in_filterData = filterData;
            return bool_physx_PxRigidBodyExt_linearSweepSingle_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_physx_PxQueryFilterDataPtr_C_(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_closestHit, pvk_in_shapeIndex, pvk_in_filterData);
        }
        
        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr)) {
            return linearSweepSingle(body, scene, &unitDir, distance, outputFlags, closestHit, shapeIndex, filterData, filterCall);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern bool bool_physx_PxRigidBodyExt_linearSweepSingle_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_physx_PxQueryFilterDataPtr_physx_PxQueryFilterCallbackPtr_C_(physx.PxRigidBodyPtr pvk_body, physx.PxScenePtr pvk_scene, physx.PxVec3* pvk_unitDir, float pvk_distance, PxHitFlagsPtr pvk_outputFlags, physx.PxSweepHitPtr pvk_closestHit, uint* pvk_shapeIndex, physx.PxQueryFilterDataPtr pvk_filterData, physx.PxQueryFilterCallbackPtr pvk_filterCall);
        
        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr)) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            PxHitFlagsPtr pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_closestHit = closestHit;
            uint* pvk_in_shapeIndex = shapeIndex;
            physx.PxQueryFilterDataPtr pvk_in_filterData = filterData;
            physx.PxQueryFilterCallbackPtr pvk_in_filterCall = filterCall;
            return bool_physx_PxRigidBodyExt_linearSweepSingle_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_physx_PxQueryFilterDataPtr_physx_PxQueryFilterCallbackPtr_C_(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_closestHit, pvk_in_shapeIndex, pvk_in_filterData, pvk_in_filterCall);
        }
        
        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr)) {
            return linearSweepSingle(body, scene, &unitDir, distance, outputFlags, closestHit, shapeIndex, filterData, filterCall, cache);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern bool bool_physx_PxRigidBodyExt_linearSweepSingle_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_physx_PxQueryFilterDataPtr_physx_PxQueryFilterCallbackPtr_physx_PxQueryCachePtr_C_(physx.PxRigidBodyPtr pvk_body, physx.PxScenePtr pvk_scene, physx.PxVec3* pvk_unitDir, float pvk_distance, PxHitFlagsPtr pvk_outputFlags, physx.PxSweepHitPtr pvk_closestHit, uint* pvk_shapeIndex, physx.PxQueryFilterDataPtr pvk_filterData, physx.PxQueryFilterCallbackPtr pvk_filterCall, physx.PxQueryCachePtr pvk_cache);
        
        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr)) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            PxHitFlagsPtr pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_closestHit = closestHit;
            uint* pvk_in_shapeIndex = shapeIndex;
            physx.PxQueryFilterDataPtr pvk_in_filterData = filterData;
            physx.PxQueryFilterCallbackPtr pvk_in_filterCall = filterCall;
            physx.PxQueryCachePtr pvk_in_cache = cache;
            return bool_physx_PxRigidBodyExt_linearSweepSingle_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_physx_PxQueryFilterDataPtr_physx_PxQueryFilterCallbackPtr_physx_PxQueryCachePtr_C_(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_closestHit, pvk_in_shapeIndex, pvk_in_filterData, pvk_in_filterCall, pvk_in_cache);
        }
        
        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr), float inflation=0f) {
            return linearSweepSingle(body, scene, &unitDir, distance, outputFlags, closestHit, shapeIndex, filterData, filterCall, cache, inflation);
        }
        
        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow) {
            return linearSweepMultiple(body, scene, &unitDir, distance, outputFlags, touchHitBuffer, touchHitShapeIndices, touchHitBufferSize, block, blockingShapeIndex, overflow);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern uint uint_physx_PxRigidBodyExt_linearSweepMultiple_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_uint_physx_PxSweepHitPtr_int_bool_C_(physx.PxRigidBodyPtr pvk_body, physx.PxScenePtr pvk_scene, physx.PxVec3* pvk_unitDir, float pvk_distance, PxHitFlagsPtr pvk_outputFlags, physx.PxSweepHitPtr pvk_touchHitBuffer, uint* pvk_touchHitShapeIndices, uint pvk_touchHitBufferSize, physx.PxSweepHitPtr pvk_block, int* pvk_blockingShapeIndex, bool* pvk_overflow);
        
        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            PxHitFlagsPtr pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_touchHitBuffer = touchHitBuffer;
            uint* pvk_in_touchHitShapeIndices = touchHitShapeIndices;
            uint pvk_in_touchHitBufferSize = touchHitBufferSize;
            physx.PxSweepHitPtr pvk_in_block = block;
            int* pvk_in_blockingShapeIndex = blockingShapeIndex;
            bool* pvk_in_overflow = overflow;
            return uint_physx_PxRigidBodyExt_linearSweepMultiple_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_uint_physx_PxSweepHitPtr_int_bool_C_(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_touchHitBuffer, pvk_in_touchHitShapeIndices, pvk_in_touchHitBufferSize, pvk_in_block, pvk_in_blockingShapeIndex, pvk_in_overflow);
        }
        
        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData) {
            return linearSweepMultiple(body, scene, &unitDir, distance, outputFlags, touchHitBuffer, touchHitShapeIndices, touchHitBufferSize, block, blockingShapeIndex, overflow, filterData);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern uint uint_physx_PxRigidBodyExt_linearSweepMultiple_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_uint_physx_PxSweepHitPtr_int_bool_physx_PxQueryFilterDataPtr_C_(physx.PxRigidBodyPtr pvk_body, physx.PxScenePtr pvk_scene, physx.PxVec3* pvk_unitDir, float pvk_distance, PxHitFlagsPtr pvk_outputFlags, physx.PxSweepHitPtr pvk_touchHitBuffer, uint* pvk_touchHitShapeIndices, uint pvk_touchHitBufferSize, physx.PxSweepHitPtr pvk_block, int* pvk_blockingShapeIndex, bool* pvk_overflow, physx.PxQueryFilterDataPtr pvk_filterData);
        
        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            PxHitFlagsPtr pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_touchHitBuffer = touchHitBuffer;
            uint* pvk_in_touchHitShapeIndices = touchHitShapeIndices;
            uint pvk_in_touchHitBufferSize = touchHitBufferSize;
            physx.PxSweepHitPtr pvk_in_block = block;
            int* pvk_in_blockingShapeIndex = blockingShapeIndex;
            bool* pvk_in_overflow = overflow;
            physx.PxQueryFilterDataPtr pvk_in_filterData = filterData;
            return uint_physx_PxRigidBodyExt_linearSweepMultiple_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_uint_physx_PxSweepHitPtr_int_bool_physx_PxQueryFilterDataPtr_C_(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_touchHitBuffer, pvk_in_touchHitShapeIndices, pvk_in_touchHitBufferSize, pvk_in_block, pvk_in_blockingShapeIndex, pvk_in_overflow, pvk_in_filterData);
        }
        
        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr)) {
            return linearSweepMultiple(body, scene, &unitDir, distance, outputFlags, touchHitBuffer, touchHitShapeIndices, touchHitBufferSize, block, blockingShapeIndex, overflow, filterData, filterCall);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern uint uint_physx_PxRigidBodyExt_linearSweepMultiple_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_uint_physx_PxSweepHitPtr_int_bool_physx_PxQueryFilterDataPtr_physx_PxQueryFilterCallbackPtr_C_(physx.PxRigidBodyPtr pvk_body, physx.PxScenePtr pvk_scene, physx.PxVec3* pvk_unitDir, float pvk_distance, PxHitFlagsPtr pvk_outputFlags, physx.PxSweepHitPtr pvk_touchHitBuffer, uint* pvk_touchHitShapeIndices, uint pvk_touchHitBufferSize, physx.PxSweepHitPtr pvk_block, int* pvk_blockingShapeIndex, bool* pvk_overflow, physx.PxQueryFilterDataPtr pvk_filterData, physx.PxQueryFilterCallbackPtr pvk_filterCall);
        
        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr)) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            PxHitFlagsPtr pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_touchHitBuffer = touchHitBuffer;
            uint* pvk_in_touchHitShapeIndices = touchHitShapeIndices;
            uint pvk_in_touchHitBufferSize = touchHitBufferSize;
            physx.PxSweepHitPtr pvk_in_block = block;
            int* pvk_in_blockingShapeIndex = blockingShapeIndex;
            bool* pvk_in_overflow = overflow;
            physx.PxQueryFilterDataPtr pvk_in_filterData = filterData;
            physx.PxQueryFilterCallbackPtr pvk_in_filterCall = filterCall;
            return uint_physx_PxRigidBodyExt_linearSweepMultiple_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_uint_physx_PxSweepHitPtr_int_bool_physx_PxQueryFilterDataPtr_physx_PxQueryFilterCallbackPtr_C_(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_touchHitBuffer, pvk_in_touchHitShapeIndices, pvk_in_touchHitBufferSize, pvk_in_block, pvk_in_blockingShapeIndex, pvk_in_overflow, pvk_in_filterData, pvk_in_filterCall);
        }
        
        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr)) {
            return linearSweepMultiple(body, scene, &unitDir, distance, outputFlags, touchHitBuffer, touchHitShapeIndices, touchHitBufferSize, block, blockingShapeIndex, overflow, filterData, filterCall, cache);
        }
        
        [DllImport(SharpPhysX.Lib, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl)]
        static extern uint uint_physx_PxRigidBodyExt_linearSweepMultiple_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_uint_physx_PxSweepHitPtr_int_bool_physx_PxQueryFilterDataPtr_physx_PxQueryFilterCallbackPtr_physx_PxQueryCachePtr_C_(physx.PxRigidBodyPtr pvk_body, physx.PxScenePtr pvk_scene, physx.PxVec3* pvk_unitDir, float pvk_distance, PxHitFlagsPtr pvk_outputFlags, physx.PxSweepHitPtr pvk_touchHitBuffer, uint* pvk_touchHitShapeIndices, uint pvk_touchHitBufferSize, physx.PxSweepHitPtr pvk_block, int* pvk_blockingShapeIndex, bool* pvk_overflow, physx.PxQueryFilterDataPtr pvk_filterData, physx.PxQueryFilterCallbackPtr pvk_filterCall, physx.PxQueryCachePtr pvk_cache);
        
        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr)) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            PxHitFlagsPtr pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_touchHitBuffer = touchHitBuffer;
            uint* pvk_in_touchHitShapeIndices = touchHitShapeIndices;
            uint pvk_in_touchHitBufferSize = touchHitBufferSize;
            physx.PxSweepHitPtr pvk_in_block = block;
            int* pvk_in_blockingShapeIndex = blockingShapeIndex;
            bool* pvk_in_overflow = overflow;
            physx.PxQueryFilterDataPtr pvk_in_filterData = filterData;
            physx.PxQueryFilterCallbackPtr pvk_in_filterCall = filterCall;
            physx.PxQueryCachePtr pvk_in_cache = cache;
            return uint_physx_PxRigidBodyExt_linearSweepMultiple_physx_PxRigidBodyPtr_physx_PxScenePtr_physx_PxVec3_float_PxHitFlagsPtr_physx_PxSweepHitPtr_uint_uint_physx_PxSweepHitPtr_int_bool_physx_PxQueryFilterDataPtr_physx_PxQueryFilterCallbackPtr_physx_PxQueryCachePtr_C_(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_touchHitBuffer, pvk_in_touchHitShapeIndices, pvk_in_touchHitBufferSize, pvk_in_block, pvk_in_blockingShapeIndex, pvk_in_overflow, pvk_in_filterData, pvk_in_filterCall, pvk_in_cache);
        }
        
        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, PxHitFlagsPtr outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr), float inflation=0f) {
            return linearSweepMultiple(body, scene, &unitDir, distance, outputFlags, touchHitBuffer, touchHitShapeIndices, touchHitBufferSize, block, blockingShapeIndex, overflow, filterData, filterCall, cache, inflation);
        }
        
        public static void computeVelocityDeltaFromImpulse(physx.PxRigidBodyPtr body, physx.PxVec3 impulsiveForce, physx.PxVec3 impulsiveTorque, physx.PxVec3 deltaLinearVelocity, physx.PxVec3 deltaAngularVelocity) {
            computeVelocityDeltaFromImpulse(body, &impulsiveForce, &impulsiveTorque, &deltaLinearVelocity, &deltaAngularVelocity);
        }
        
        public static void computeVelocityDeltaFromImpulse(physx.PxRigidBodyPtr body, physx.PxTransform globalPose, physx.PxVec3 point, physx.PxVec3 impulse, float invMassScale, float invInertiaScale, physx.PxVec3 deltaLinearVelocity, physx.PxVec3 deltaAngularVelocity) {
            computeVelocityDeltaFromImpulse(body, &globalPose, &point, &impulse, invMassScale, invInertiaScale, &deltaLinearVelocity, &deltaAngularVelocity);
        }
        
        public static void computeLinearAngularImpulse(physx.PxRigidBodyPtr body, physx.PxTransform globalPose, physx.PxVec3 point, physx.PxVec3 impulse, float invMassScale, float invInertiaScale, physx.PxVec3 linearImpulse, physx.PxVec3 angularImpulse) {
            computeLinearAngularImpulse(body, &globalPose, &point, &impulse, invMassScale, invInertiaScale, &linearImpulse, &angularImpulse);
        }
    }
    
}
