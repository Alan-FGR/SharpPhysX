// Generated by minBND 5.1.93.2 - Â© github.com/Alan-FGR
using System;
using System.Runtime.InteropServices;
using static minBND_pinvokes;

public static unsafe partial class physx {

    public static unsafe partial class PxRigidBodyExt {

        public static bool updateMassAndInertia(physx.PxRigidBodyPtr body, float* shapeDensities, uint shapeDensityCount, physx.PxVec3* massLocalPose, bool includeNonSimShapes=false) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float* pvk_in_shapeDensities = shapeDensities;
            uint pvk_in_shapeDensityCount = shapeDensityCount;
            physx.PxVec3* pvk_in_massLocalPose = massLocalPose;
            bool pvk_in_includeNonSimShapes = includeNonSimShapes;
            return bool_PxRigidBodyExtPtr_updateMassAndInertiaPtr_PxRigidBodyPtr_float_uint_PxVec3_bool_(pvk_in_body, pvk_in_shapeDensities, pvk_in_shapeDensityCount, pvk_in_massLocalPose, pvk_in_includeNonSimShapes);
        }

        public static bool updateMassAndInertia(physx.PxRigidBodyPtr body, float density, physx.PxVec3* massLocalPose, bool includeNonSimShapes=false) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float pvk_in_density = density;
            physx.PxVec3* pvk_in_massLocalPose = massLocalPose;
            bool pvk_in_includeNonSimShapes = includeNonSimShapes;
            return bool_PxRigidBodyExtPtr_updateMassAndInertiaPtr_PxRigidBodyPtr_float_PxVec3_bool_(pvk_in_body, pvk_in_density, pvk_in_massLocalPose, pvk_in_includeNonSimShapes);
        }

        public static bool setMassAndUpdateInertia(physx.PxRigidBodyPtr body, float* shapeMasses, uint shapeMassCount, physx.PxVec3* massLocalPose, bool includeNonSimShapes=false) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float* pvk_in_shapeMasses = shapeMasses;
            uint pvk_in_shapeMassCount = shapeMassCount;
            physx.PxVec3* pvk_in_massLocalPose = massLocalPose;
            bool pvk_in_includeNonSimShapes = includeNonSimShapes;
            return bool_PxRigidBodyExtPtr_setMassAndUpdateInertiaPtr_PxRigidBodyPtr_float_uint_PxVec3_bool_(pvk_in_body, pvk_in_shapeMasses, pvk_in_shapeMassCount, pvk_in_massLocalPose, pvk_in_includeNonSimShapes);
        }

        public static bool setMassAndUpdateInertia(physx.PxRigidBodyPtr body, float mass, physx.PxVec3* massLocalPose, bool includeNonSimShapes=false) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float pvk_in_mass = mass;
            physx.PxVec3* pvk_in_massLocalPose = massLocalPose;
            bool pvk_in_includeNonSimShapes = includeNonSimShapes;
            return bool_PxRigidBodyExtPtr_setMassAndUpdateInertiaPtr_PxRigidBodyPtr_float_PxVec3_bool_(pvk_in_body, pvk_in_mass, pvk_in_massLocalPose, pvk_in_includeNonSimShapes);
        }

        public static physx.PxMassPropertiesPtr computeMassPropertiesFromShapes_New(physx.PxShapePtr* shapes, uint shapeCount) {
            physx.PxShapePtr* pvk_in_shapes = shapes;
            uint pvk_in_shapeCount = shapeCount;
            return PxMassPropertiesPtr_PxRigidBodyExtPtr_computeMassPropertiesFromShapesPtr_PxShapePtr_uint_(pvk_in_shapes, pvk_in_shapeCount);
        }

        public static void addForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            physx.PxForceModeEnum pvk_in_mode = mode;
            bool pvk_in_wakeup = wakeup;
            void_PxRigidBodyExtPtr_addForceAtPosPtr_PxRigidBodyPtr_PxVec3_PxVec3_PxForceModeEnum_bool_(pvk_in_body, pvk_in_force, pvk_in_pos, pvk_in_mode, pvk_in_wakeup);
        }

        public static void addForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            physx.PxForceModeEnum pvk_in_mode = mode;
            bool pvk_in_wakeup = wakeup;
            void_PxRigidBodyExtPtr_addForceAtLocalPosPtr_PxRigidBodyPtr_PxVec3_PxVec3_PxForceModeEnum_bool_(pvk_in_body, pvk_in_force, pvk_in_pos, pvk_in_mode, pvk_in_wakeup);
        }

        public static void addLocalForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            physx.PxForceModeEnum pvk_in_mode = mode;
            bool pvk_in_wakeup = wakeup;
            void_PxRigidBodyExtPtr_addLocalForceAtPosPtr_PxRigidBodyPtr_PxVec3_PxVec3_PxForceModeEnum_bool_(pvk_in_body, pvk_in_force, pvk_in_pos, pvk_in_mode, pvk_in_wakeup);
        }

        public static void addLocalForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            physx.PxForceModeEnum pvk_in_mode = mode;
            bool pvk_in_wakeup = wakeup;
            void_PxRigidBodyExtPtr_addLocalForceAtLocalPosPtr_PxRigidBodyPtr_PxVec3_PxVec3_PxForceModeEnum_bool_(pvk_in_body, pvk_in_force, pvk_in_pos, pvk_in_mode, pvk_in_wakeup);
        }

        public static physx.PxVec3 getVelocityAtPos(physx.PxRigidBodyPtr body, physx.PxVec3* pos) {
            physx.PxVec3 RetRef;
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_pos = pos;
            PxVec3_PxRigidBodyExtPtr_getVelocityAtPosPtr_PxRigidBodyPtr_PxVec3_(&RetRef, pvk_in_body, pvk_in_pos);
            return RetRef;
        }

        public static physx.PxVec3 getLocalVelocityAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3* pos) {
            physx.PxVec3 RetRef;
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_pos = pos;
            PxVec3_PxRigidBodyExtPtr_getLocalVelocityAtLocalPosPtr_PxRigidBodyPtr_PxVec3_(&RetRef, pvk_in_body, pvk_in_pos);
            return RetRef;
        }

        public static physx.PxVec3 getVelocityAtOffset(physx.PxRigidBodyPtr body, physx.PxVec3* pos) {
            physx.PxVec3 RetRef;
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_pos = pos;
            PxVec3_PxRigidBodyExtPtr_getVelocityAtOffsetPtr_PxRigidBodyPtr_PxVec3_(&RetRef, pvk_in_body, pvk_in_pos);
            return RetRef;
        }

        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr), float inflation=0f) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            physx.PxHitFlags pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_closestHit = closestHit;
            uint* pvk_in_shapeIndex = shapeIndex;
            physx.PxQueryFilterDataPtr pvk_in_filterData = filterData;
            physx.PxQueryFilterCallbackPtr pvk_in_filterCall = filterCall;
            physx.PxQueryCachePtr pvk_in_cache = cache;
            float pvk_in_inflation = inflation;
            return bool_PxRigidBodyExtPtr_linearSweepSinglePtr_PxRigidBodyPtr_PxScenePtr_PxVec3_float_PxHitFlags_PxSweepHitPtr_uint_PxQueryFilterDataPtr_PxQueryFilterCallbackPtr_PxQueryCachePtr_float_C_C(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_closestHit, pvk_in_shapeIndex, pvk_in_filterData, pvk_in_filterCall, pvk_in_cache, pvk_in_inflation);
        }

        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr), float inflation=0f) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            physx.PxHitFlags pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_touchHitBuffer = touchHitBuffer;
            uint* pvk_in_touchHitShapeIndices = touchHitShapeIndices;
            uint pvk_in_touchHitBufferSize = touchHitBufferSize;
            physx.PxSweepHitPtr pvk_in_block = block;
            int* pvk_in_blockingShapeIndex = blockingShapeIndex;
            bool* pvk_in_overflow = overflow;
            physx.PxQueryFilterDataPtr pvk_in_filterData = filterData;
            physx.PxQueryFilterCallbackPtr pvk_in_filterCall = filterCall;
            physx.PxQueryCachePtr pvk_in_cache = cache;
            float pvk_in_inflation = inflation;
            return uint_PxRigidBodyExtPtr_linearSweepMultiplePtr_PxRigidBodyPtr_PxScenePtr_PxVec3_float_PxHitFlags_PxSweepHitPtr_uint_uint_PxSweepHitPtr_int_bool_PxQueryFilterDataPtr_PxQueryFilterCallbackPtr_PxQueryCachePtr_float_C_C(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_touchHitBuffer, pvk_in_touchHitShapeIndices, pvk_in_touchHitBufferSize, pvk_in_block, pvk_in_blockingShapeIndex, pvk_in_overflow, pvk_in_filterData, pvk_in_filterCall, pvk_in_cache, pvk_in_inflation);
        }

        public static void computeVelocityDeltaFromImpulse(physx.PxRigidBodyPtr body, physx.PxVec3* impulsiveForce, physx.PxVec3* impulsiveTorque, physx.PxVec3* deltaLinearVelocity, physx.PxVec3* deltaAngularVelocity) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_impulsiveForce = impulsiveForce;
            physx.PxVec3* pvk_in_impulsiveTorque = impulsiveTorque;
            physx.PxVec3* pvk_in_deltaLinearVelocity = deltaLinearVelocity;
            physx.PxVec3* pvk_in_deltaAngularVelocity = deltaAngularVelocity;
            void_PxRigidBodyExtPtr_computeVelocityDeltaFromImpulsePtr_PxRigidBodyPtr_PxVec3_PxVec3_PxVec3_PxVec3_(pvk_in_body, pvk_in_impulsiveForce, pvk_in_impulsiveTorque, pvk_in_deltaLinearVelocity, pvk_in_deltaAngularVelocity);
        }

        public static void computeVelocityDeltaFromImpulse(physx.PxRigidBodyPtr body, physx.PxTransform* globalPose, physx.PxVec3* point, physx.PxVec3* impulse, float invMassScale, float invInertiaScale, physx.PxVec3* deltaLinearVelocity, physx.PxVec3* deltaAngularVelocity) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxTransform* pvk_in_globalPose = globalPose;
            physx.PxVec3* pvk_in_point = point;
            physx.PxVec3* pvk_in_impulse = impulse;
            float pvk_in_invMassScale = invMassScale;
            float pvk_in_invInertiaScale = invInertiaScale;
            physx.PxVec3* pvk_in_deltaLinearVelocity = deltaLinearVelocity;
            physx.PxVec3* pvk_in_deltaAngularVelocity = deltaAngularVelocity;
            void_PxRigidBodyExtPtr_computeVelocityDeltaFromImpulsePtr_PxRigidBodyPtr_PxTransform_PxVec3_PxVec3_float_float_PxVec3_PxVec3_CC_(pvk_in_body, pvk_in_globalPose, pvk_in_point, pvk_in_impulse, pvk_in_invMassScale, pvk_in_invInertiaScale, pvk_in_deltaLinearVelocity, pvk_in_deltaAngularVelocity);
        }

        public static void computeLinearAngularImpulse(physx.PxRigidBodyPtr body, physx.PxTransform* globalPose, physx.PxVec3* point, physx.PxVec3* impulse, float invMassScale, float invInertiaScale, physx.PxVec3* linearImpulse, physx.PxVec3* angularImpulse) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxTransform* pvk_in_globalPose = globalPose;
            physx.PxVec3* pvk_in_point = point;
            physx.PxVec3* pvk_in_impulse = impulse;
            float pvk_in_invMassScale = invMassScale;
            float pvk_in_invInertiaScale = invInertiaScale;
            physx.PxVec3* pvk_in_linearImpulse = linearImpulse;
            physx.PxVec3* pvk_in_angularImpulse = angularImpulse;
            void_PxRigidBodyExtPtr_computeLinearAngularImpulsePtr_PxRigidBodyPtr_PxTransform_PxVec3_PxVec3_float_float_PxVec3_PxVec3_CC_(pvk_in_body, pvk_in_globalPose, pvk_in_point, pvk_in_impulse, pvk_in_invMassScale, pvk_in_invInertiaScale, pvk_in_linearImpulse, pvk_in_angularImpulse);
        }

        public static bool updateMassAndInertia(physx.PxRigidBodyPtr body, float* shapeDensities, uint shapeDensityCount) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float* pvk_in_shapeDensities = shapeDensities;
            uint pvk_in_shapeDensityCount = shapeDensityCount;
            return bool_PxRigidBodyExtPtr_updateMassAndInertiaPtr_PxRigidBodyPtr_float_uint_(pvk_in_body, pvk_in_shapeDensities, pvk_in_shapeDensityCount);
        }

        public static bool updateMassAndInertia(physx.PxRigidBodyPtr body, float* shapeDensities, uint shapeDensityCount, physx.PxVec3* massLocalPose) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float* pvk_in_shapeDensities = shapeDensities;
            uint pvk_in_shapeDensityCount = shapeDensityCount;
            physx.PxVec3* pvk_in_massLocalPose = massLocalPose;
            return bool_PxRigidBodyExtPtr_updateMassAndInertiaPtr_PxRigidBodyPtr_float_uint_PxVec3_(pvk_in_body, pvk_in_shapeDensities, pvk_in_shapeDensityCount, pvk_in_massLocalPose);
        }

        public static bool updateMassAndInertia(physx.PxRigidBodyPtr body, float density) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float pvk_in_density = density;
            return bool_PxRigidBodyExtPtr_updateMassAndInertiaPtr_PxRigidBodyPtr_float_(pvk_in_body, pvk_in_density);
        }

        public static bool updateMassAndInertia(physx.PxRigidBodyPtr body, float density, physx.PxVec3* massLocalPose) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float pvk_in_density = density;
            physx.PxVec3* pvk_in_massLocalPose = massLocalPose;
            return bool_PxRigidBodyExtPtr_updateMassAndInertiaPtr_PxRigidBodyPtr_float_PxVec3_(pvk_in_body, pvk_in_density, pvk_in_massLocalPose);
        }

        public static bool setMassAndUpdateInertia(physx.PxRigidBodyPtr body, float* shapeMasses, uint shapeMassCount) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float* pvk_in_shapeMasses = shapeMasses;
            uint pvk_in_shapeMassCount = shapeMassCount;
            return bool_PxRigidBodyExtPtr_setMassAndUpdateInertiaPtr_PxRigidBodyPtr_float_uint_(pvk_in_body, pvk_in_shapeMasses, pvk_in_shapeMassCount);
        }

        public static bool setMassAndUpdateInertia(physx.PxRigidBodyPtr body, float* shapeMasses, uint shapeMassCount, physx.PxVec3* massLocalPose) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float* pvk_in_shapeMasses = shapeMasses;
            uint pvk_in_shapeMassCount = shapeMassCount;
            physx.PxVec3* pvk_in_massLocalPose = massLocalPose;
            return bool_PxRigidBodyExtPtr_setMassAndUpdateInertiaPtr_PxRigidBodyPtr_float_uint_PxVec3_(pvk_in_body, pvk_in_shapeMasses, pvk_in_shapeMassCount, pvk_in_massLocalPose);
        }

        public static bool setMassAndUpdateInertia(physx.PxRigidBodyPtr body, float mass) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float pvk_in_mass = mass;
            return bool_PxRigidBodyExtPtr_setMassAndUpdateInertiaPtr_PxRigidBodyPtr_float_(pvk_in_body, pvk_in_mass);
        }

        public static bool setMassAndUpdateInertia(physx.PxRigidBodyPtr body, float mass, physx.PxVec3* massLocalPose) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            float pvk_in_mass = mass;
            physx.PxVec3* pvk_in_massLocalPose = massLocalPose;
            return bool_PxRigidBodyExtPtr_setMassAndUpdateInertiaPtr_PxRigidBodyPtr_float_PxVec3_(pvk_in_body, pvk_in_mass, pvk_in_massLocalPose);
        }

        public static void addForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos) {
            addForceAtPos(body, (physx.PxVec3*)&force, (physx.PxVec3*)&pos);
        }

        public static void addForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3.Ref force, physx.PxVec3.Ref pos) {
            addForceAtPos(body, (physx.PxVec3*)(*((IntPtr*)(&force))), (physx.PxVec3*)(*((IntPtr*)(&pos))));
        }

        public static void addForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            void_PxRigidBodyExtPtr_addForceAtPosPtr_PxRigidBodyPtr_PxVec3_PxVec3_(pvk_in_body, pvk_in_force, pvk_in_pos);
        }

        public static void addForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos, physx.PxForceModeEnum mode) {
            addForceAtPos(body, (physx.PxVec3*)&force, (physx.PxVec3*)&pos, mode);
        }

        public static void addForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3.Ref force, physx.PxVec3.Ref pos, physx.PxForceModeEnum mode) {
            addForceAtPos(body, (physx.PxVec3*)(*((IntPtr*)(&force))), (physx.PxVec3*)(*((IntPtr*)(&pos))), mode);
        }

        public static void addForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos, physx.PxForceModeEnum mode) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            physx.PxForceModeEnum pvk_in_mode = mode;
            void_PxRigidBodyExtPtr_addForceAtPosPtr_PxRigidBodyPtr_PxVec3_PxVec3_PxForceModeEnum_(pvk_in_body, pvk_in_force, pvk_in_pos, pvk_in_mode);
        }

        public static void addForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            addForceAtPos(body, (physx.PxVec3*)&force, (physx.PxVec3*)&pos, mode, wakeup);
        }

        public static void addForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3.Ref force, physx.PxVec3.Ref pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            addForceAtPos(body, (physx.PxVec3*)(*((IntPtr*)(&force))), (physx.PxVec3*)(*((IntPtr*)(&pos))), mode, wakeup);
        }

        public static void addForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos) {
            addForceAtLocalPos(body, (physx.PxVec3*)&force, (physx.PxVec3*)&pos);
        }

        public static void addForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3.Ref force, physx.PxVec3.Ref pos) {
            addForceAtLocalPos(body, (physx.PxVec3*)(*((IntPtr*)(&force))), (physx.PxVec3*)(*((IntPtr*)(&pos))));
        }

        public static void addForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            void_PxRigidBodyExtPtr_addForceAtLocalPosPtr_PxRigidBodyPtr_PxVec3_PxVec3_(pvk_in_body, pvk_in_force, pvk_in_pos);
        }

        public static void addForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos, physx.PxForceModeEnum mode) {
            addForceAtLocalPos(body, (physx.PxVec3*)&force, (physx.PxVec3*)&pos, mode);
        }

        public static void addForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3.Ref force, physx.PxVec3.Ref pos, physx.PxForceModeEnum mode) {
            addForceAtLocalPos(body, (physx.PxVec3*)(*((IntPtr*)(&force))), (physx.PxVec3*)(*((IntPtr*)(&pos))), mode);
        }

        public static void addForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos, physx.PxForceModeEnum mode) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            physx.PxForceModeEnum pvk_in_mode = mode;
            void_PxRigidBodyExtPtr_addForceAtLocalPosPtr_PxRigidBodyPtr_PxVec3_PxVec3_PxForceModeEnum_(pvk_in_body, pvk_in_force, pvk_in_pos, pvk_in_mode);
        }

        public static void addForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            addForceAtLocalPos(body, (physx.PxVec3*)&force, (physx.PxVec3*)&pos, mode, wakeup);
        }

        public static void addForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3.Ref force, physx.PxVec3.Ref pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            addForceAtLocalPos(body, (physx.PxVec3*)(*((IntPtr*)(&force))), (physx.PxVec3*)(*((IntPtr*)(&pos))), mode, wakeup);
        }

        public static void addLocalForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos) {
            addLocalForceAtPos(body, (physx.PxVec3*)&force, (physx.PxVec3*)&pos);
        }

        public static void addLocalForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3.Ref force, physx.PxVec3.Ref pos) {
            addLocalForceAtPos(body, (physx.PxVec3*)(*((IntPtr*)(&force))), (physx.PxVec3*)(*((IntPtr*)(&pos))));
        }

        public static void addLocalForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            void_PxRigidBodyExtPtr_addLocalForceAtPosPtr_PxRigidBodyPtr_PxVec3_PxVec3_(pvk_in_body, pvk_in_force, pvk_in_pos);
        }

        public static void addLocalForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos, physx.PxForceModeEnum mode) {
            addLocalForceAtPos(body, (physx.PxVec3*)&force, (physx.PxVec3*)&pos, mode);
        }

        public static void addLocalForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3.Ref force, physx.PxVec3.Ref pos, physx.PxForceModeEnum mode) {
            addLocalForceAtPos(body, (physx.PxVec3*)(*((IntPtr*)(&force))), (physx.PxVec3*)(*((IntPtr*)(&pos))), mode);
        }

        public static void addLocalForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos, physx.PxForceModeEnum mode) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            physx.PxForceModeEnum pvk_in_mode = mode;
            void_PxRigidBodyExtPtr_addLocalForceAtPosPtr_PxRigidBodyPtr_PxVec3_PxVec3_PxForceModeEnum_(pvk_in_body, pvk_in_force, pvk_in_pos, pvk_in_mode);
        }

        public static void addLocalForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            addLocalForceAtPos(body, (physx.PxVec3*)&force, (physx.PxVec3*)&pos, mode, wakeup);
        }

        public static void addLocalForceAtPos(physx.PxRigidBodyPtr body, physx.PxVec3.Ref force, physx.PxVec3.Ref pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            addLocalForceAtPos(body, (physx.PxVec3*)(*((IntPtr*)(&force))), (physx.PxVec3*)(*((IntPtr*)(&pos))), mode, wakeup);
        }

        public static void addLocalForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos) {
            addLocalForceAtLocalPos(body, (physx.PxVec3*)&force, (physx.PxVec3*)&pos);
        }

        public static void addLocalForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3.Ref force, physx.PxVec3.Ref pos) {
            addLocalForceAtLocalPos(body, (physx.PxVec3*)(*((IntPtr*)(&force))), (physx.PxVec3*)(*((IntPtr*)(&pos))));
        }

        public static void addLocalForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            void_PxRigidBodyExtPtr_addLocalForceAtLocalPosPtr_PxRigidBodyPtr_PxVec3_PxVec3_(pvk_in_body, pvk_in_force, pvk_in_pos);
        }

        public static void addLocalForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos, physx.PxForceModeEnum mode) {
            addLocalForceAtLocalPos(body, (physx.PxVec3*)&force, (physx.PxVec3*)&pos, mode);
        }

        public static void addLocalForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3.Ref force, physx.PxVec3.Ref pos, physx.PxForceModeEnum mode) {
            addLocalForceAtLocalPos(body, (physx.PxVec3*)(*((IntPtr*)(&force))), (physx.PxVec3*)(*((IntPtr*)(&pos))), mode);
        }

        public static void addLocalForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3* force, physx.PxVec3* pos, physx.PxForceModeEnum mode) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxVec3* pvk_in_force = force;
            physx.PxVec3* pvk_in_pos = pos;
            physx.PxForceModeEnum pvk_in_mode = mode;
            void_PxRigidBodyExtPtr_addLocalForceAtLocalPosPtr_PxRigidBodyPtr_PxVec3_PxVec3_PxForceModeEnum_(pvk_in_body, pvk_in_force, pvk_in_pos, pvk_in_mode);
        }

        public static void addLocalForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3 force, physx.PxVec3 pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            addLocalForceAtLocalPos(body, (physx.PxVec3*)&force, (physx.PxVec3*)&pos, mode, wakeup);
        }

        public static void addLocalForceAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3.Ref force, physx.PxVec3.Ref pos, physx.PxForceModeEnum mode, bool wakeup=true) {
            addLocalForceAtLocalPos(body, (physx.PxVec3*)(*((IntPtr*)(&force))), (physx.PxVec3*)(*((IntPtr*)(&pos))), mode, wakeup);
        }

        public static physx.PxVec3 getVelocityAtPos(physx.PxRigidBodyPtr body, physx.PxVec3 pos) {
            return getVelocityAtPos(body, (physx.PxVec3*)&pos);
        }

        public static physx.PxVec3 getVelocityAtPos(physx.PxRigidBodyPtr body, physx.PxVec3.Ref pos) {
            return getVelocityAtPos(body, (physx.PxVec3*)(*((IntPtr*)(&pos))));
        }

        public static physx.PxVec3 getLocalVelocityAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3 pos) {
            return getLocalVelocityAtLocalPos(body, (physx.PxVec3*)&pos);
        }

        public static physx.PxVec3 getLocalVelocityAtLocalPos(physx.PxRigidBodyPtr body, physx.PxVec3.Ref pos) {
            return getLocalVelocityAtLocalPos(body, (physx.PxVec3*)(*((IntPtr*)(&pos))));
        }

        public static physx.PxVec3 getVelocityAtOffset(physx.PxRigidBodyPtr body, physx.PxVec3 pos) {
            return getVelocityAtOffset(body, (physx.PxVec3*)&pos);
        }

        public static physx.PxVec3 getVelocityAtOffset(physx.PxRigidBodyPtr body, physx.PxVec3.Ref pos) {
            return getVelocityAtOffset(body, (physx.PxVec3*)(*((IntPtr*)(&pos))));
        }

        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex) {
            return linearSweepSingle(body, scene, (physx.PxVec3*)&unitDir, distance, outputFlags, closestHit, shapeIndex);
        }

        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3.Ref unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex) {
            return linearSweepSingle(body, scene, (physx.PxVec3*)(*((IntPtr*)(&unitDir))), distance, outputFlags, closestHit, shapeIndex);
        }

        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            physx.PxHitFlags pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_closestHit = closestHit;
            uint* pvk_in_shapeIndex = shapeIndex;
            return bool_PxRigidBodyExtPtr_linearSweepSinglePtr_PxRigidBodyPtr_PxScenePtr_PxVec3_float_PxHitFlags_PxSweepHitPtr_uint_C_(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_closestHit, pvk_in_shapeIndex);
        }

        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData) {
            return linearSweepSingle(body, scene, (physx.PxVec3*)&unitDir, distance, outputFlags, closestHit, shapeIndex, filterData);
        }

        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3.Ref unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData) {
            return linearSweepSingle(body, scene, (physx.PxVec3*)(*((IntPtr*)(&unitDir))), distance, outputFlags, closestHit, shapeIndex, filterData);
        }

        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            physx.PxHitFlags pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_closestHit = closestHit;
            uint* pvk_in_shapeIndex = shapeIndex;
            physx.PxQueryFilterDataPtr pvk_in_filterData = filterData;
            return bool_PxRigidBodyExtPtr_linearSweepSinglePtr_PxRigidBodyPtr_PxScenePtr_PxVec3_float_PxHitFlags_PxSweepHitPtr_uint_PxQueryFilterDataPtr_C_(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_closestHit, pvk_in_shapeIndex, pvk_in_filterData);
        }

        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr)) {
            return linearSweepSingle(body, scene, (physx.PxVec3*)&unitDir, distance, outputFlags, closestHit, shapeIndex, filterData, filterCall);
        }

        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3.Ref unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr)) {
            return linearSweepSingle(body, scene, (physx.PxVec3*)(*((IntPtr*)(&unitDir))), distance, outputFlags, closestHit, shapeIndex, filterData, filterCall);
        }

        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr)) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            physx.PxHitFlags pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_closestHit = closestHit;
            uint* pvk_in_shapeIndex = shapeIndex;
            physx.PxQueryFilterDataPtr pvk_in_filterData = filterData;
            physx.PxQueryFilterCallbackPtr pvk_in_filterCall = filterCall;
            return bool_PxRigidBodyExtPtr_linearSweepSinglePtr_PxRigidBodyPtr_PxScenePtr_PxVec3_float_PxHitFlags_PxSweepHitPtr_uint_PxQueryFilterDataPtr_PxQueryFilterCallbackPtr_C_(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_closestHit, pvk_in_shapeIndex, pvk_in_filterData, pvk_in_filterCall);
        }

        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr)) {
            return linearSweepSingle(body, scene, (physx.PxVec3*)&unitDir, distance, outputFlags, closestHit, shapeIndex, filterData, filterCall, cache);
        }

        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3.Ref unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr)) {
            return linearSweepSingle(body, scene, (physx.PxVec3*)(*((IntPtr*)(&unitDir))), distance, outputFlags, closestHit, shapeIndex, filterData, filterCall, cache);
        }

        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr)) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            physx.PxHitFlags pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_closestHit = closestHit;
            uint* pvk_in_shapeIndex = shapeIndex;
            physx.PxQueryFilterDataPtr pvk_in_filterData = filterData;
            physx.PxQueryFilterCallbackPtr pvk_in_filterCall = filterCall;
            physx.PxQueryCachePtr pvk_in_cache = cache;
            return bool_PxRigidBodyExtPtr_linearSweepSinglePtr_PxRigidBodyPtr_PxScenePtr_PxVec3_float_PxHitFlags_PxSweepHitPtr_uint_PxQueryFilterDataPtr_PxQueryFilterCallbackPtr_PxQueryCachePtr_C_(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_closestHit, pvk_in_shapeIndex, pvk_in_filterData, pvk_in_filterCall, pvk_in_cache);
        }

        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr), float inflation=0f) {
            return linearSweepSingle(body, scene, (physx.PxVec3*)&unitDir, distance, outputFlags, closestHit, shapeIndex, filterData, filterCall, cache, inflation);
        }

        public static bool linearSweepSingle(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3.Ref unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr closestHit, uint* shapeIndex, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr), float inflation=0f) {
            return linearSweepSingle(body, scene, (physx.PxVec3*)(*((IntPtr*)(&unitDir))), distance, outputFlags, closestHit, shapeIndex, filterData, filterCall, cache, inflation);
        }

        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow) {
            return linearSweepMultiple(body, scene, (physx.PxVec3*)&unitDir, distance, outputFlags, touchHitBuffer, touchHitShapeIndices, touchHitBufferSize, block, blockingShapeIndex, overflow);
        }

        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3.Ref unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow) {
            return linearSweepMultiple(body, scene, (physx.PxVec3*)(*((IntPtr*)(&unitDir))), distance, outputFlags, touchHitBuffer, touchHitShapeIndices, touchHitBufferSize, block, blockingShapeIndex, overflow);
        }

        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            physx.PxHitFlags pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_touchHitBuffer = touchHitBuffer;
            uint* pvk_in_touchHitShapeIndices = touchHitShapeIndices;
            uint pvk_in_touchHitBufferSize = touchHitBufferSize;
            physx.PxSweepHitPtr pvk_in_block = block;
            int* pvk_in_blockingShapeIndex = blockingShapeIndex;
            bool* pvk_in_overflow = overflow;
            return uint_PxRigidBodyExtPtr_linearSweepMultiplePtr_PxRigidBodyPtr_PxScenePtr_PxVec3_float_PxHitFlags_PxSweepHitPtr_uint_uint_PxSweepHitPtr_int_bool_C_(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_touchHitBuffer, pvk_in_touchHitShapeIndices, pvk_in_touchHitBufferSize, pvk_in_block, pvk_in_blockingShapeIndex, pvk_in_overflow);
        }

        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData) {
            return linearSweepMultiple(body, scene, (physx.PxVec3*)&unitDir, distance, outputFlags, touchHitBuffer, touchHitShapeIndices, touchHitBufferSize, block, blockingShapeIndex, overflow, filterData);
        }

        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3.Ref unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData) {
            return linearSweepMultiple(body, scene, (physx.PxVec3*)(*((IntPtr*)(&unitDir))), distance, outputFlags, touchHitBuffer, touchHitShapeIndices, touchHitBufferSize, block, blockingShapeIndex, overflow, filterData);
        }

        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            physx.PxHitFlags pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_touchHitBuffer = touchHitBuffer;
            uint* pvk_in_touchHitShapeIndices = touchHitShapeIndices;
            uint pvk_in_touchHitBufferSize = touchHitBufferSize;
            physx.PxSweepHitPtr pvk_in_block = block;
            int* pvk_in_blockingShapeIndex = blockingShapeIndex;
            bool* pvk_in_overflow = overflow;
            physx.PxQueryFilterDataPtr pvk_in_filterData = filterData;
            return uint_PxRigidBodyExtPtr_linearSweepMultiplePtr_PxRigidBodyPtr_PxScenePtr_PxVec3_float_PxHitFlags_PxSweepHitPtr_uint_uint_PxSweepHitPtr_int_bool_PxQueryFilterDataPtr_C_(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_touchHitBuffer, pvk_in_touchHitShapeIndices, pvk_in_touchHitBufferSize, pvk_in_block, pvk_in_blockingShapeIndex, pvk_in_overflow, pvk_in_filterData);
        }

        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr)) {
            return linearSweepMultiple(body, scene, (physx.PxVec3*)&unitDir, distance, outputFlags, touchHitBuffer, touchHitShapeIndices, touchHitBufferSize, block, blockingShapeIndex, overflow, filterData, filterCall);
        }

        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3.Ref unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr)) {
            return linearSweepMultiple(body, scene, (physx.PxVec3*)(*((IntPtr*)(&unitDir))), distance, outputFlags, touchHitBuffer, touchHitShapeIndices, touchHitBufferSize, block, blockingShapeIndex, overflow, filterData, filterCall);
        }

        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr)) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            physx.PxHitFlags pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_touchHitBuffer = touchHitBuffer;
            uint* pvk_in_touchHitShapeIndices = touchHitShapeIndices;
            uint pvk_in_touchHitBufferSize = touchHitBufferSize;
            physx.PxSweepHitPtr pvk_in_block = block;
            int* pvk_in_blockingShapeIndex = blockingShapeIndex;
            bool* pvk_in_overflow = overflow;
            physx.PxQueryFilterDataPtr pvk_in_filterData = filterData;
            physx.PxQueryFilterCallbackPtr pvk_in_filterCall = filterCall;
            return uint_PxRigidBodyExtPtr_linearSweepMultiplePtr_PxRigidBodyPtr_PxScenePtr_PxVec3_float_PxHitFlags_PxSweepHitPtr_uint_uint_PxSweepHitPtr_int_bool_PxQueryFilterDataPtr_PxQueryFilterCallbackPtr_C_(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_touchHitBuffer, pvk_in_touchHitShapeIndices, pvk_in_touchHitBufferSize, pvk_in_block, pvk_in_blockingShapeIndex, pvk_in_overflow, pvk_in_filterData, pvk_in_filterCall);
        }

        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr)) {
            return linearSweepMultiple(body, scene, (physx.PxVec3*)&unitDir, distance, outputFlags, touchHitBuffer, touchHitShapeIndices, touchHitBufferSize, block, blockingShapeIndex, overflow, filterData, filterCall, cache);
        }

        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3.Ref unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr)) {
            return linearSweepMultiple(body, scene, (physx.PxVec3*)(*((IntPtr*)(&unitDir))), distance, outputFlags, touchHitBuffer, touchHitShapeIndices, touchHitBufferSize, block, blockingShapeIndex, overflow, filterData, filterCall, cache);
        }

        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3* unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr)) {
            physx.PxRigidBodyPtr pvk_in_body = body;
            physx.PxScenePtr pvk_in_scene = scene;
            physx.PxVec3* pvk_in_unitDir = unitDir;
            float pvk_in_distance = distance;
            physx.PxHitFlags pvk_in_outputFlags = outputFlags;
            physx.PxSweepHitPtr pvk_in_touchHitBuffer = touchHitBuffer;
            uint* pvk_in_touchHitShapeIndices = touchHitShapeIndices;
            uint pvk_in_touchHitBufferSize = touchHitBufferSize;
            physx.PxSweepHitPtr pvk_in_block = block;
            int* pvk_in_blockingShapeIndex = blockingShapeIndex;
            bool* pvk_in_overflow = overflow;
            physx.PxQueryFilterDataPtr pvk_in_filterData = filterData;
            physx.PxQueryFilterCallbackPtr pvk_in_filterCall = filterCall;
            physx.PxQueryCachePtr pvk_in_cache = cache;
            return uint_PxRigidBodyExtPtr_linearSweepMultiplePtr_PxRigidBodyPtr_PxScenePtr_PxVec3_float_PxHitFlags_PxSweepHitPtr_uint_uint_PxSweepHitPtr_int_bool_PxQueryFilterDataPtr_PxQueryFilterCallbackPtr_PxQueryCachePtr_C_(pvk_in_body, pvk_in_scene, pvk_in_unitDir, pvk_in_distance, pvk_in_outputFlags, pvk_in_touchHitBuffer, pvk_in_touchHitShapeIndices, pvk_in_touchHitBufferSize, pvk_in_block, pvk_in_blockingShapeIndex, pvk_in_overflow, pvk_in_filterData, pvk_in_filterCall, pvk_in_cache);
        }

        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3 unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr), float inflation=0f) {
            return linearSweepMultiple(body, scene, (physx.PxVec3*)&unitDir, distance, outputFlags, touchHitBuffer, touchHitShapeIndices, touchHitBufferSize, block, blockingShapeIndex, overflow, filterData, filterCall, cache, inflation);
        }

        public static uint linearSweepMultiple(physx.PxRigidBodyPtr body, physx.PxScenePtr scene, physx.PxVec3.Ref unitDir, float distance, physx.PxHitFlags outputFlags, physx.PxSweepHitPtr touchHitBuffer, uint* touchHitShapeIndices, uint touchHitBufferSize, physx.PxSweepHitPtr block, int* blockingShapeIndex, bool* overflow, physx.PxQueryFilterDataPtr filterData, physx.PxQueryFilterCallbackPtr filterCall=default(physx.PxQueryFilterCallbackPtr), physx.PxQueryCachePtr cache=default(physx.PxQueryCachePtr), float inflation=0f) {
            return linearSweepMultiple(body, scene, (physx.PxVec3*)(*((IntPtr*)(&unitDir))), distance, outputFlags, touchHitBuffer, touchHitShapeIndices, touchHitBufferSize, block, blockingShapeIndex, overflow, filterData, filterCall, cache, inflation);
        }

        public static void computeVelocityDeltaFromImpulse(physx.PxRigidBodyPtr body, physx.PxVec3 impulsiveForce, physx.PxVec3 impulsiveTorque, physx.PxVec3 deltaLinearVelocity, physx.PxVec3 deltaAngularVelocity) {
            computeVelocityDeltaFromImpulse(body, (physx.PxVec3*)&impulsiveForce, (physx.PxVec3*)&impulsiveTorque, (physx.PxVec3*)&deltaLinearVelocity, (physx.PxVec3*)&deltaAngularVelocity);
        }

        public static void computeVelocityDeltaFromImpulse(physx.PxRigidBodyPtr body, physx.PxVec3.Ref impulsiveForce, physx.PxVec3.Ref impulsiveTorque, physx.PxVec3.Ref deltaLinearVelocity, physx.PxVec3.Ref deltaAngularVelocity) {
            computeVelocityDeltaFromImpulse(body, (physx.PxVec3*)(*((IntPtr*)(&impulsiveForce))), (physx.PxVec3*)(*((IntPtr*)(&impulsiveTorque))), (physx.PxVec3*)(*((IntPtr*)(&deltaLinearVelocity))), (physx.PxVec3*)(*((IntPtr*)(&deltaAngularVelocity))));
        }

        public static void computeVelocityDeltaFromImpulse(physx.PxRigidBodyPtr body, physx.PxTransform globalPose, physx.PxVec3 point, physx.PxVec3 impulse, float invMassScale, float invInertiaScale, physx.PxVec3 deltaLinearVelocity, physx.PxVec3 deltaAngularVelocity) {
            computeVelocityDeltaFromImpulse(body, (physx.PxTransform*)&globalPose, (physx.PxVec3*)&point, (physx.PxVec3*)&impulse, invMassScale, invInertiaScale, (physx.PxVec3*)&deltaLinearVelocity, (physx.PxVec3*)&deltaAngularVelocity);
        }

        public static void computeVelocityDeltaFromImpulse(physx.PxRigidBodyPtr body, physx.PxTransform.Ref globalPose, physx.PxVec3.Ref point, physx.PxVec3.Ref impulse, float invMassScale, float invInertiaScale, physx.PxVec3.Ref deltaLinearVelocity, physx.PxVec3.Ref deltaAngularVelocity) {
            computeVelocityDeltaFromImpulse(body, (physx.PxTransform*)(*((IntPtr*)(&globalPose))), (physx.PxVec3*)(*((IntPtr*)(&point))), (physx.PxVec3*)(*((IntPtr*)(&impulse))), invMassScale, invInertiaScale, (physx.PxVec3*)(*((IntPtr*)(&deltaLinearVelocity))), (physx.PxVec3*)(*((IntPtr*)(&deltaAngularVelocity))));
        }

        public static void computeLinearAngularImpulse(physx.PxRigidBodyPtr body, physx.PxTransform globalPose, physx.PxVec3 point, physx.PxVec3 impulse, float invMassScale, float invInertiaScale, physx.PxVec3 linearImpulse, physx.PxVec3 angularImpulse) {
            computeLinearAngularImpulse(body, (physx.PxTransform*)&globalPose, (physx.PxVec3*)&point, (physx.PxVec3*)&impulse, invMassScale, invInertiaScale, (physx.PxVec3*)&linearImpulse, (physx.PxVec3*)&angularImpulse);
        }

        public static void computeLinearAngularImpulse(physx.PxRigidBodyPtr body, physx.PxTransform.Ref globalPose, physx.PxVec3.Ref point, physx.PxVec3.Ref impulse, float invMassScale, float invInertiaScale, physx.PxVec3.Ref linearImpulse, physx.PxVec3.Ref angularImpulse) {
            computeLinearAngularImpulse(body, (physx.PxTransform*)(*((IntPtr*)(&globalPose))), (physx.PxVec3*)(*((IntPtr*)(&point))), (physx.PxVec3*)(*((IntPtr*)(&impulse))), invMassScale, invInertiaScale, (physx.PxVec3*)(*((IntPtr*)(&linearImpulse))), (physx.PxVec3*)(*((IntPtr*)(&angularImpulse))));
        }
    }
}
