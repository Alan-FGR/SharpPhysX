// Generated by minBND 5.1.91.17 - Â© github.com/Alan-FGR

ES Px1DConstraintFlagsPtr Px1DConstraintFlagsPtr_operator_Ptr_Pipe_Px1DConstraintFlagPtr_Type_Px1DConstraintFlagPtr_Type_(physx::Px1DConstraintFlag::Type wrp_a, physx::Px1DConstraintFlag::Type wrp_b){
    auto ret = ::physx::operator|(wrp_a, wrp_b);
    auto heap = new char[sizeof Px1DConstraintFlags];
    std::memcpy(heap, &ret, sizeof Px1DConstraintFlags);
    return (Px1DConstraintFlagsPtr) heap;
}

ES Px1DConstraintFlagsPtr Px1DConstraintFlagsPtr_operator_Ptr_Amp_Px1DConstraintFlagPtr_Type_Px1DConstraintFlagPtr_Type_(physx::Px1DConstraintFlag::Type wrp_a, physx::Px1DConstraintFlag::Type wrp_b){
    auto ret = ::physx::operator&(wrp_a, wrp_b);
    auto heap = new char[sizeof Px1DConstraintFlags];
    std::memcpy(heap, &ret, sizeof Px1DConstraintFlags);
    return (Px1DConstraintFlagsPtr) heap;
}

ES Px1DConstraintFlagsPtr Px1DConstraintFlagsPtr_operator_Ptr_Tilde_Px1DConstraintFlagPtr_Type_(physx::Px1DConstraintFlag::Type wrp_a){
    auto ret = ::physx::operator~(wrp_a);
    auto heap = new char[sizeof Px1DConstraintFlags];
    std::memcpy(heap, &ret, sizeof Px1DConstraintFlags);
    return (Px1DConstraintFlagsPtr) heap;
}

ES void Freer_physx_Px1DConstraintFlagPtr(Px1DConstraintFlagPtr ptr){
    delete ptr;
}

ES Px1DConstraintFlagPtr Ctor_Px1DConstraintFlagPtr_(){
    auto ret = *(new std::remove_pointer<Px1DConstraintFlagPtr>::type());
    auto heap = new char[sizeof Px1DConstraintFlag];
    std::memcpy(heap, &ret, sizeof Px1DConstraintFlag);
    return (Px1DConstraintFlagPtr) heap;
}

ES SpringModifiersPtr Newer_physx_Px1DConstraintPtr_physx_Px1DConstraint_ANONYMOUS_unionPtr_SpringModifiersPtr(){
    return new std::remove_pointer<SpringModifiersPtr>::type();
}
ES void Freer_physx_Px1DConstraintPtr_physx_Px1DConstraint_ANONYMOUS_unionPtr_SpringModifiersPtr(SpringModifiersPtr ptr){
    delete ptr;
}

ES PxReal SpringModifiersPtr_GET_stiffness(SpringModifiersPtr cls) {return (PxReal)cls->stiffness;}
ES void SpringModifiersPtr_SET_stiffness(SpringModifiersPtr cls, PxReal value) {cls->stiffness = value;}

ES PxReal SpringModifiersPtr_GET_damping(SpringModifiersPtr cls) {return (PxReal)cls->damping;}
ES void SpringModifiersPtr_SET_damping(SpringModifiersPtr cls, PxReal value) {cls->damping = value;}

ES RestitutionModifiersPtr Newer_physx_Px1DConstraintPtr_physx_Px1DConstraint_ANONYMOUS_unionPtr_RestitutionModifiersPtr(){
    return new std::remove_pointer<RestitutionModifiersPtr>::type();
}
ES void Freer_physx_Px1DConstraintPtr_physx_Px1DConstraint_ANONYMOUS_unionPtr_RestitutionModifiersPtr(RestitutionModifiersPtr ptr){
    delete ptr;
}

ES PxReal RestitutionModifiersPtr_GET_restitution(RestitutionModifiersPtr cls) {return (PxReal)cls->restitution;}
ES void RestitutionModifiersPtr_SET_restitution(RestitutionModifiersPtr cls, PxReal value) {cls->restitution = value;}

ES PxReal RestitutionModifiersPtr_GET_velocityThreshold(RestitutionModifiersPtr cls) {return (PxReal)cls->velocityThreshold;}
ES void RestitutionModifiersPtr_SET_velocityThreshold(RestitutionModifiersPtr cls, PxReal value) {cls->velocityThreshold = value;}

ES physx_Px1DConstraint_ANONYMOUS_unionPtr Newer_physx_Px1DConstraintPtr_physx_Px1DConstraint_ANONYMOUS_unionPtr(){
    return new std::remove_pointer<physx_Px1DConstraint_ANONYMOUS_unionPtr>::type();
}
ES void Freer_physx_Px1DConstraintPtr_physx_Px1DConstraint_ANONYMOUS_unionPtr(physx_Px1DConstraint_ANONYMOUS_unionPtr ptr){
    delete ptr;
}

ES SpringModifiersPtr physx_Px1DConstraint_ANONYMOUS_unionPtr_GET_spring(physx_Px1DConstraint_ANONYMOUS_unionPtr cls) {return (SpringModifiersPtr)&cls->spring;}
ES void physx_Px1DConstraint_ANONYMOUS_unionPtr_SET_spring(physx_Px1DConstraint_ANONYMOUS_unionPtr cls, SpringModifiersPtr value) {cls->spring = *value;}

ES RestitutionModifiersPtr physx_Px1DConstraint_ANONYMOUS_unionPtr_GET_bounce(physx_Px1DConstraint_ANONYMOUS_unionPtr cls) {return (RestitutionModifiersPtr)&cls->bounce;}
ES void physx_Px1DConstraint_ANONYMOUS_unionPtr_SET_bounce(physx_Px1DConstraint_ANONYMOUS_unionPtr cls, RestitutionModifiersPtr value) {cls->bounce = *value;}

ES Px1DConstraintPtr Newer_physx_Px1DConstraintPtr(){
    return new std::remove_pointer<Px1DConstraintPtr>::type();
}
ES void Freer_physx_Px1DConstraintPtr(Px1DConstraintPtr ptr){
    delete ptr;
}

ES void Px1DConstraintPtr_GET_linear0(Px1DConstraintPtr cls, physx::PxVec3* GetRetRef) {*GetRetRef = cls->linear0;}
ES void Px1DConstraintPtr_SET_linear0(Px1DConstraintPtr cls, physx::PxVec3 value) {cls->linear0 = value;}

ES PxReal Px1DConstraintPtr_GET_geometricError(Px1DConstraintPtr cls) {return (PxReal)cls->geometricError;}
ES void Px1DConstraintPtr_SET_geometricError(Px1DConstraintPtr cls, PxReal value) {cls->geometricError = value;}

ES void Px1DConstraintPtr_GET_angular0(Px1DConstraintPtr cls, physx::PxVec3* GetRetRef) {*GetRetRef = cls->angular0;}
ES void Px1DConstraintPtr_SET_angular0(Px1DConstraintPtr cls, physx::PxVec3 value) {cls->angular0 = value;}

ES PxReal Px1DConstraintPtr_GET_velocityTarget(Px1DConstraintPtr cls) {return (PxReal)cls->velocityTarget;}
ES void Px1DConstraintPtr_SET_velocityTarget(Px1DConstraintPtr cls, PxReal value) {cls->velocityTarget = value;}

ES void Px1DConstraintPtr_GET_linear1(Px1DConstraintPtr cls, physx::PxVec3* GetRetRef) {*GetRetRef = cls->linear1;}
ES void Px1DConstraintPtr_SET_linear1(Px1DConstraintPtr cls, physx::PxVec3 value) {cls->linear1 = value;}

ES PxReal Px1DConstraintPtr_GET_minImpulse(Px1DConstraintPtr cls) {return (PxReal)cls->minImpulse;}
ES void Px1DConstraintPtr_SET_minImpulse(Px1DConstraintPtr cls, PxReal value) {cls->minImpulse = value;}

ES void Px1DConstraintPtr_GET_angular1(Px1DConstraintPtr cls, physx::PxVec3* GetRetRef) {*GetRetRef = cls->angular1;}
ES void Px1DConstraintPtr_SET_angular1(Px1DConstraintPtr cls, physx::PxVec3 value) {cls->angular1 = value;}

ES PxReal Px1DConstraintPtr_GET_maxImpulse(Px1DConstraintPtr cls) {return (PxReal)cls->maxImpulse;}
ES void Px1DConstraintPtr_SET_maxImpulse(Px1DConstraintPtr cls, PxReal value) {cls->maxImpulse = value;}

ES physx_Px1DConstraint_ANONYMOUS_unionPtr Px1DConstraintPtr_GET_mods(Px1DConstraintPtr cls) {return (physx_Px1DConstraint_ANONYMOUS_unionPtr)&cls->mods;}
ES void Px1DConstraintPtr_SET_mods(Px1DConstraintPtr cls, physx_Px1DConstraint_ANONYMOUS_unionPtr value) {cls->mods = *value;}

ES PxReal Px1DConstraintPtr_GET_forInternalUse(Px1DConstraintPtr cls) {return (PxReal)cls->forInternalUse;}
ES void Px1DConstraintPtr_SET_forInternalUse(Px1DConstraintPtr cls, PxReal value) {cls->forInternalUse = value;}

ES PxU16 Px1DConstraintPtr_GET_flags(Px1DConstraintPtr cls) {return (PxU16)cls->flags;}
ES void Px1DConstraintPtr_SET_flags(Px1DConstraintPtr cls, PxU16 value) {cls->flags = value;}

ES PxU16 Px1DConstraintPtr_GET_solveHint(Px1DConstraintPtr cls) {return (PxU16)cls->solveHint;}
ES void Px1DConstraintPtr_SET_solveHint(Px1DConstraintPtr cls, PxU16 value) {cls->solveHint = value;}

ES void Freer_physx_PxConstraintInvMassScalePtr(PxConstraintInvMassScalePtr ptr){
    delete ptr;
}

ES PxConstraintInvMassScalePtr Ctor_PxConstraintInvMassScalePtr_(){
    auto ret = *(new std::remove_pointer<PxConstraintInvMassScalePtr>::type());
    auto heap = new char[sizeof PxConstraintInvMassScale];
    std::memcpy(heap, &ret, sizeof PxConstraintInvMassScale);
    return (PxConstraintInvMassScalePtr) heap;
}

ES PxConstraintInvMassScalePtr Ctor_PxConstraintInvMassScalePtr_float_float_float_float(PxReal wrp_lin0, PxReal wrp_ang0, PxReal wrp_lin1, PxReal wrp_ang1){
    auto ret = *(new std::remove_pointer<PxConstraintInvMassScalePtr>::type(wrp_lin0, wrp_ang0, wrp_lin1, wrp_ang1));
    auto heap = new char[sizeof PxConstraintInvMassScale];
    std::memcpy(heap, &ret, sizeof PxConstraintInvMassScale);
    return (PxConstraintInvMassScalePtr) heap;
}

ES PxReal PxConstraintInvMassScalePtr_GET_linear0(PxConstraintInvMassScalePtr cls) {return (PxReal)cls->linear0;}
ES void PxConstraintInvMassScalePtr_SET_linear0(PxConstraintInvMassScalePtr cls, PxReal value) {cls->linear0 = value;}

ES PxReal PxConstraintInvMassScalePtr_GET_angular0(PxConstraintInvMassScalePtr cls) {return (PxReal)cls->angular0;}
ES void PxConstraintInvMassScalePtr_SET_angular0(PxConstraintInvMassScalePtr cls, PxReal value) {cls->angular0 = value;}

ES PxReal PxConstraintInvMassScalePtr_GET_linear1(PxConstraintInvMassScalePtr cls) {return (PxReal)cls->linear1;}
ES void PxConstraintInvMassScalePtr_SET_linear1(PxConstraintInvMassScalePtr cls, PxReal value) {cls->linear1 = value;}

ES PxReal PxConstraintInvMassScalePtr_GET_angular1(PxConstraintInvMassScalePtr cls) {return (PxReal)cls->angular1;}
ES void PxConstraintInvMassScalePtr_SET_angular1(PxConstraintInvMassScalePtr cls, PxReal value) {cls->angular1 = value;}

ES void void_PxConstraintVisualizerPtr_visualizeJointFramesPtr_PxTransform_PxTransform_(PxConstraintVisualizerPtr wrp_this, physx::PxTransform* wrp_parent, physx::PxTransform* wrp_child){
    wrp_this->visualizeJointFrames(*wrp_parent, *wrp_child);
}

ES void void_PxConstraintVisualizerPtr_visualizeLinearLimitPtr_PxTransform_PxTransform_float_bool_(PxConstraintVisualizerPtr wrp_this, physx::PxTransform* wrp_t0, physx::PxTransform* wrp_t1, PxReal wrp_value, bool wrp_active){
    wrp_this->visualizeLinearLimit(*wrp_t0, *wrp_t1, wrp_value, wrp_active);
}

ES void void_PxConstraintVisualizerPtr_visualizeAngularLimitPtr_PxTransform_float_float_bool_(PxConstraintVisualizerPtr wrp_this, physx::PxTransform* wrp_t0, PxReal wrp_lower, PxReal wrp_upper, bool wrp_active){
    wrp_this->visualizeAngularLimit(*wrp_t0, wrp_lower, wrp_upper, wrp_active);
}

ES void void_PxConstraintVisualizerPtr_visualizeLimitConePtr_PxTransform_float_float_bool_(PxConstraintVisualizerPtr wrp_this, physx::PxTransform* wrp_t, PxReal wrp_tanQSwingY, PxReal wrp_tanQSwingZ, bool wrp_active){
    wrp_this->visualizeLimitCone(*wrp_t, wrp_tanQSwingY, wrp_tanQSwingZ, wrp_active);
}

ES void void_PxConstraintVisualizerPtr_visualizeDoubleConePtr_PxTransform_float_bool_(PxConstraintVisualizerPtr wrp_this, physx::PxTransform* wrp_t, PxReal wrp_angle, bool wrp_active){
    wrp_this->visualizeDoubleCone(*wrp_t, wrp_angle, wrp_active);
}

ES void void_PxConstraintVisualizerPtr_visualizeLinePtr_PxVec3_PxVec3_uint_(PxConstraintVisualizerPtr wrp_this, physx::PxVec3* wrp_p0, physx::PxVec3* wrp_p1, PxU32 wrp_color){
    wrp_this->visualizeLine(*wrp_p0, *wrp_p1, wrp_color);
}

ES void* IntPtr_PxConstraintConnectorPtr_prepareDataPtr(PxConstraintConnectorPtr wrp_this){
    return (void*) wrp_this->prepareData();
}

ES void void_PxConstraintConnectorPtr_onConstraintReleasePtr(PxConstraintConnectorPtr wrp_this){
    wrp_this->onConstraintRelease();
}

ES void void_PxConstraintConnectorPtr_onComShiftPtr_uint_(PxConstraintConnectorPtr wrp_this, PxU32 wrp_actor){
    wrp_this->onComShift(wrp_actor);
}

ES void void_PxConstraintConnectorPtr_onOriginShiftPtr_PxVec3_(PxConstraintConnectorPtr wrp_this, physx::PxVec3* wrp_shift){
    wrp_this->onOriginShift(*wrp_shift);
}

ES void* IntPtr_PxConstraintConnectorPtr_getExternalReferencePtr_uint_(PxConstraintConnectorPtr wrp_this, PxU32* wrp_typeID){
    return (void*) wrp_this->getExternalReference(*wrp_typeID);
}

ES PxBasePtr PxBasePtr_PxConstraintConnectorPtr_getSerializablePtr(PxConstraintConnectorPtr wrp_this){
    return (PxBasePtr) wrp_this->getSerializable();
}

ES PxConstraintSolverPrep PxConstraintSolverPrep_const_PxConstraintConnectorPtr_getPrepPtr(PxConstraintConnectorPtr wrp_this){
    return (PxConstraintSolverPrep) wrp_this->getPrep();
}

ES void* IntPtr_const_PxConstraintConnectorPtr_getConstantBlockPtr(PxConstraintConnectorPtr wrp_this){
    return (void*) wrp_this->getConstantBlock();
}

