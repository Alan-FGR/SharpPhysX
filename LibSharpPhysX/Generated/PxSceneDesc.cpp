// Generated by minBND 5.1.93.2 - Â© github.com/Alan-FGR

ES PxSceneFlagsPtr PxSceneFlagsPtr_operator_Ptr_Pipe_PxSceneFlagEnum_PxSceneFlagEnum_(physx::PxSceneFlag::Enum wrp_a, physx::PxSceneFlag::Enum wrp_b){
    auto ret = ::physx::operator|(wrp_a, wrp_b);
    auto heap = new char[sizeof PxSceneFlags];
    std::memcpy(heap, &ret, sizeof PxSceneFlags);
    return (PxSceneFlagsPtr) heap;
}

ES PxSceneFlagsPtr PxSceneFlagsPtr_operator_Ptr_Amp_PxSceneFlagEnum_PxSceneFlagEnum_(physx::PxSceneFlag::Enum wrp_a, physx::PxSceneFlag::Enum wrp_b){
    auto ret = ::physx::operator&(wrp_a, wrp_b);
    auto heap = new char[sizeof PxSceneFlags];
    std::memcpy(heap, &ret, sizeof PxSceneFlags);
    return (PxSceneFlagsPtr) heap;
}

ES PxSceneFlagsPtr PxSceneFlagsPtr_operator_Ptr_Tilde_PxSceneFlagEnum_(physx::PxSceneFlag::Enum wrp_a){
    auto ret = ::physx::operator~(wrp_a);
    auto heap = new char[sizeof PxSceneFlags];
    std::memcpy(heap, &ret, sizeof PxSceneFlags);
    return (PxSceneFlagsPtr) heap;
}

ES void Freer_physx_PxSceneLimitsPtr(PxSceneLimitsPtr ptr){
    delete ptr;
}

ES PxSceneLimitsPtr Ctor_PxSceneLimitsPtr_(){
    auto ret = *(new std::remove_pointer<PxSceneLimitsPtr>::type());
    auto heap = new char[sizeof PxSceneLimits];
    std::memcpy(heap, &ret, sizeof PxSceneLimits);
    return (PxSceneLimitsPtr) heap;
}

ES PxU32 PxSceneLimitsPtr_GET_maxNbActors(PxSceneLimitsPtr cls) {return (PxU32)cls->maxNbActors;}
ES void PxSceneLimitsPtr_SET_maxNbActors(PxSceneLimitsPtr cls, PxU32 value) {cls->maxNbActors = value;}

ES PxU32 PxSceneLimitsPtr_GET_maxNbBodies(PxSceneLimitsPtr cls) {return (PxU32)cls->maxNbBodies;}
ES void PxSceneLimitsPtr_SET_maxNbBodies(PxSceneLimitsPtr cls, PxU32 value) {cls->maxNbBodies = value;}

ES PxU32 PxSceneLimitsPtr_GET_maxNbStaticShapes(PxSceneLimitsPtr cls) {return (PxU32)cls->maxNbStaticShapes;}
ES void PxSceneLimitsPtr_SET_maxNbStaticShapes(PxSceneLimitsPtr cls, PxU32 value) {cls->maxNbStaticShapes = value;}

ES PxU32 PxSceneLimitsPtr_GET_maxNbDynamicShapes(PxSceneLimitsPtr cls) {return (PxU32)cls->maxNbDynamicShapes;}
ES void PxSceneLimitsPtr_SET_maxNbDynamicShapes(PxSceneLimitsPtr cls, PxU32 value) {cls->maxNbDynamicShapes = value;}

ES PxU32 PxSceneLimitsPtr_GET_maxNbAggregates(PxSceneLimitsPtr cls) {return (PxU32)cls->maxNbAggregates;}
ES void PxSceneLimitsPtr_SET_maxNbAggregates(PxSceneLimitsPtr cls, PxU32 value) {cls->maxNbAggregates = value;}

ES PxU32 PxSceneLimitsPtr_GET_maxNbConstraints(PxSceneLimitsPtr cls) {return (PxU32)cls->maxNbConstraints;}
ES void PxSceneLimitsPtr_SET_maxNbConstraints(PxSceneLimitsPtr cls, PxU32 value) {cls->maxNbConstraints = value;}

ES PxU32 PxSceneLimitsPtr_GET_maxNbRegions(PxSceneLimitsPtr cls) {return (PxU32)cls->maxNbRegions;}
ES void PxSceneLimitsPtr_SET_maxNbRegions(PxSceneLimitsPtr cls, PxU32 value) {cls->maxNbRegions = value;}

ES PxU32 PxSceneLimitsPtr_GET_maxNbBroadPhaseOverlaps(PxSceneLimitsPtr cls) {return (PxU32)cls->maxNbBroadPhaseOverlaps;}
ES void PxSceneLimitsPtr_SET_maxNbBroadPhaseOverlaps(PxSceneLimitsPtr cls, PxU32 value) {cls->maxNbBroadPhaseOverlaps = value;}

ES void void_PxSceneLimitsPtr_setToDefaultPtr(PxSceneLimitsPtr wrp_this){
    wrp_this->setToDefault();
}

ES bool bool_const_PxSceneLimitsPtr_isValidPtr(PxSceneLimitsPtr wrp_this){
    return (bool) wrp_this->isValid();
}

ES void Freer_physx_PxgDynamicsMemoryConfigPtr(PxgDynamicsMemoryConfigPtr ptr){
    delete ptr;
}

ES PxgDynamicsMemoryConfigPtr Ctor_PxgDynamicsMemoryConfigPtr_(){
    auto ret = *(new std::remove_pointer<PxgDynamicsMemoryConfigPtr>::type());
    auto heap = new char[sizeof PxgDynamicsMemoryConfig];
    std::memcpy(heap, &ret, sizeof PxgDynamicsMemoryConfig);
    return (PxgDynamicsMemoryConfigPtr) heap;
}

ES PxU32 PxgDynamicsMemoryConfigPtr_GET_constraintBufferCapacity(PxgDynamicsMemoryConfigPtr cls) {return (PxU32)cls->constraintBufferCapacity;}
ES void PxgDynamicsMemoryConfigPtr_SET_constraintBufferCapacity(PxgDynamicsMemoryConfigPtr cls, PxU32 value) {cls->constraintBufferCapacity = value;}

ES PxU32 PxgDynamicsMemoryConfigPtr_GET_contactBufferCapacity(PxgDynamicsMemoryConfigPtr cls) {return (PxU32)cls->contactBufferCapacity;}
ES void PxgDynamicsMemoryConfigPtr_SET_contactBufferCapacity(PxgDynamicsMemoryConfigPtr cls, PxU32 value) {cls->contactBufferCapacity = value;}

ES PxU32 PxgDynamicsMemoryConfigPtr_GET_tempBufferCapacity(PxgDynamicsMemoryConfigPtr cls) {return (PxU32)cls->tempBufferCapacity;}
ES void PxgDynamicsMemoryConfigPtr_SET_tempBufferCapacity(PxgDynamicsMemoryConfigPtr cls, PxU32 value) {cls->tempBufferCapacity = value;}

ES PxU32 PxgDynamicsMemoryConfigPtr_GET_contactStreamSize(PxgDynamicsMemoryConfigPtr cls) {return (PxU32)cls->contactStreamSize;}
ES void PxgDynamicsMemoryConfigPtr_SET_contactStreamSize(PxgDynamicsMemoryConfigPtr cls, PxU32 value) {cls->contactStreamSize = value;}

ES PxU32 PxgDynamicsMemoryConfigPtr_GET_patchStreamSize(PxgDynamicsMemoryConfigPtr cls) {return (PxU32)cls->patchStreamSize;}
ES void PxgDynamicsMemoryConfigPtr_SET_patchStreamSize(PxgDynamicsMemoryConfigPtr cls, PxU32 value) {cls->patchStreamSize = value;}

ES PxU32 PxgDynamicsMemoryConfigPtr_GET_forceStreamCapacity(PxgDynamicsMemoryConfigPtr cls) {return (PxU32)cls->forceStreamCapacity;}
ES void PxgDynamicsMemoryConfigPtr_SET_forceStreamCapacity(PxgDynamicsMemoryConfigPtr cls, PxU32 value) {cls->forceStreamCapacity = value;}

ES PxU32 PxgDynamicsMemoryConfigPtr_GET_heapCapacity(PxgDynamicsMemoryConfigPtr cls) {return (PxU32)cls->heapCapacity;}
ES void PxgDynamicsMemoryConfigPtr_SET_heapCapacity(PxgDynamicsMemoryConfigPtr cls, PxU32 value) {cls->heapCapacity = value;}

ES PxU32 PxgDynamicsMemoryConfigPtr_GET_foundLostPairsCapacity(PxgDynamicsMemoryConfigPtr cls) {return (PxU32)cls->foundLostPairsCapacity;}
ES void PxgDynamicsMemoryConfigPtr_SET_foundLostPairsCapacity(PxgDynamicsMemoryConfigPtr cls, PxU32 value) {cls->foundLostPairsCapacity = value;}

ES void Freer_physx_PxSceneDescPtr(PxSceneDescPtr ptr){
    delete ptr;
}

ES PxSceneDescPtr Ctor_PxSceneDescPtr_PxTolerancesScale_(physx::PxTolerancesScale* wrp_scale){
    auto ret = *(new std::remove_pointer<PxSceneDescPtr>::type(*wrp_scale));
    auto heap = new char[sizeof PxSceneDesc];
    std::memcpy(heap, &ret, sizeof PxSceneDesc);
    return (PxSceneDescPtr) heap;
}

ES void PxSceneDescPtr_GET_gravity(PxSceneDescPtr cls, physx::PxVec3* GetRetRef) {*GetRetRef = cls->gravity;}
ES void PxSceneDescPtr_SET_gravity(PxSceneDescPtr cls, physx::PxVec3 value) {cls->gravity = value;}

ES void* PxSceneDescPtr_GET_filterShaderData(PxSceneDescPtr cls) {return (void*)cls->filterShaderData;}
ES void PxSceneDescPtr_SET_filterShaderData(PxSceneDescPtr cls, void* value) {cls->filterShaderData = value;}

ES PxU32 PxSceneDescPtr_GET_filterShaderDataSize(PxSceneDescPtr cls) {return (PxU32)cls->filterShaderDataSize;}
ES void PxSceneDescPtr_SET_filterShaderDataSize(PxSceneDescPtr cls, PxU32 value) {cls->filterShaderDataSize = value;}

ES PxSimulationFilterShader PxSceneDescPtr_GET_filterShader(PxSceneDescPtr cls) {return (PxSimulationFilterShader)cls->filterShader;}
ES void PxSceneDescPtr_SET_filterShader(PxSceneDescPtr cls, PxSimulationFilterShader value) {cls->filterShader = value;}

ES PxSimulationFilterCallbackPtr PxSceneDescPtr_GET_filterCallback(PxSceneDescPtr cls) {return (PxSimulationFilterCallbackPtr)cls->filterCallback;}
ES void PxSceneDescPtr_SET_filterCallback(PxSceneDescPtr cls, PxSimulationFilterCallbackPtr value) {cls->filterCallback = value;}

ES physx::PxPairFilteringMode::Enum PxSceneDescPtr_GET_kineKineFilteringMode(PxSceneDescPtr cls) {return (physx::PxPairFilteringMode::Enum)cls->kineKineFilteringMode;}
ES void PxSceneDescPtr_SET_kineKineFilteringMode(PxSceneDescPtr cls, physx::PxPairFilteringMode::Enum value) {cls->kineKineFilteringMode = value;}

ES physx::PxPairFilteringMode::Enum PxSceneDescPtr_GET_staticKineFilteringMode(PxSceneDescPtr cls) {return (physx::PxPairFilteringMode::Enum)cls->staticKineFilteringMode;}
ES void PxSceneDescPtr_SET_staticKineFilteringMode(PxSceneDescPtr cls, physx::PxPairFilteringMode::Enum value) {cls->staticKineFilteringMode = value;}

ES physx::PxBroadPhaseType::Enum PxSceneDescPtr_GET_broadPhaseType(PxSceneDescPtr cls) {return (physx::PxBroadPhaseType::Enum)cls->broadPhaseType;}
ES void PxSceneDescPtr_SET_broadPhaseType(PxSceneDescPtr cls, physx::PxBroadPhaseType::Enum value) {cls->broadPhaseType = value;}

ES PxBroadPhaseCallbackPtr PxSceneDescPtr_GET_broadPhaseCallback(PxSceneDescPtr cls) {return (PxBroadPhaseCallbackPtr)cls->broadPhaseCallback;}
ES void PxSceneDescPtr_SET_broadPhaseCallback(PxSceneDescPtr cls, PxBroadPhaseCallbackPtr value) {cls->broadPhaseCallback = value;}

ES PxSceneLimitsPtr PxSceneDescPtr_GET_limits(PxSceneDescPtr cls) {return (PxSceneLimitsPtr)&cls->limits;}
ES void PxSceneDescPtr_SET_limits(PxSceneDescPtr cls, PxSceneLimitsPtr value) {cls->limits = *value;}

ES physx::PxFrictionType::Enum PxSceneDescPtr_GET_frictionType(PxSceneDescPtr cls) {return (physx::PxFrictionType::Enum)cls->frictionType;}
ES void PxSceneDescPtr_SET_frictionType(PxSceneDescPtr cls, physx::PxFrictionType::Enum value) {cls->frictionType = value;}

ES physx::PxSolverType::Enum PxSceneDescPtr_GET_solverType(PxSceneDescPtr cls) {return (physx::PxSolverType::Enum)cls->solverType;}
ES void PxSceneDescPtr_SET_solverType(PxSceneDescPtr cls, physx::PxSolverType::Enum value) {cls->solverType = value;}

ES PxReal PxSceneDescPtr_GET_bounceThresholdVelocity(PxSceneDescPtr cls) {return (PxReal)cls->bounceThresholdVelocity;}
ES void PxSceneDescPtr_SET_bounceThresholdVelocity(PxSceneDescPtr cls, PxReal value) {cls->bounceThresholdVelocity = value;}

ES PxReal PxSceneDescPtr_GET_frictionOffsetThreshold(PxSceneDescPtr cls) {return (PxReal)cls->frictionOffsetThreshold;}
ES void PxSceneDescPtr_SET_frictionOffsetThreshold(PxSceneDescPtr cls, PxReal value) {cls->frictionOffsetThreshold = value;}

ES PxReal PxSceneDescPtr_GET_ccdMaxSeparation(PxSceneDescPtr cls) {return (PxReal)cls->ccdMaxSeparation;}
ES void PxSceneDescPtr_SET_ccdMaxSeparation(PxSceneDescPtr cls, PxReal value) {cls->ccdMaxSeparation = value;}

ES PxReal PxSceneDescPtr_GET_solverOffsetSlop(PxSceneDescPtr cls) {return (PxReal)cls->solverOffsetSlop;}
ES void PxSceneDescPtr_SET_solverOffsetSlop(PxSceneDescPtr cls, PxReal value) {cls->solverOffsetSlop = value;}

ES PxSceneFlagsPtr PxSceneDescPtr_GET_flags(PxSceneDescPtr cls) {return (PxSceneFlagsPtr)&cls->flags;}
ES void PxSceneDescPtr_SET_flags(PxSceneDescPtr cls, PxSceneFlagsPtr value) {cls->flags = *value;}

ES PxCpuDispatcherPtr PxSceneDescPtr_GET_cpuDispatcher(PxSceneDescPtr cls) {return (PxCpuDispatcherPtr)cls->cpuDispatcher;}
ES void PxSceneDescPtr_SET_cpuDispatcher(PxSceneDescPtr cls, PxCpuDispatcherPtr value) {cls->cpuDispatcher = value;}

ES PxGpuDispatcherPtr PxSceneDescPtr_GET_gpuDispatcher(PxSceneDescPtr cls) {return (PxGpuDispatcherPtr)cls->gpuDispatcher;}
ES void PxSceneDescPtr_SET_gpuDispatcher(PxSceneDescPtr cls, PxGpuDispatcherPtr value) {cls->gpuDispatcher = value;}

ES physx::PxPruningStructureType::Enum PxSceneDescPtr_GET_staticStructure(PxSceneDescPtr cls) {return (physx::PxPruningStructureType::Enum)cls->staticStructure;}
ES void PxSceneDescPtr_SET_staticStructure(PxSceneDescPtr cls, physx::PxPruningStructureType::Enum value) {cls->staticStructure = value;}

ES physx::PxPruningStructureType::Enum PxSceneDescPtr_GET_dynamicStructure(PxSceneDescPtr cls) {return (physx::PxPruningStructureType::Enum)cls->dynamicStructure;}
ES void PxSceneDescPtr_SET_dynamicStructure(PxSceneDescPtr cls, physx::PxPruningStructureType::Enum value) {cls->dynamicStructure = value;}

ES PxU32 PxSceneDescPtr_GET_dynamicTreeRebuildRateHint(PxSceneDescPtr cls) {return (PxU32)cls->dynamicTreeRebuildRateHint;}
ES void PxSceneDescPtr_SET_dynamicTreeRebuildRateHint(PxSceneDescPtr cls, PxU32 value) {cls->dynamicTreeRebuildRateHint = value;}

ES physx::PxSceneQueryUpdateMode::Enum PxSceneDescPtr_GET_sceneQueryUpdateMode(PxSceneDescPtr cls) {return (physx::PxSceneQueryUpdateMode::Enum)cls->sceneQueryUpdateMode;}
ES void PxSceneDescPtr_SET_sceneQueryUpdateMode(PxSceneDescPtr cls, physx::PxSceneQueryUpdateMode::Enum value) {cls->sceneQueryUpdateMode = value;}

ES void* PxSceneDescPtr_GET_userData(PxSceneDescPtr cls) {return (void*)cls->userData;}
ES void PxSceneDescPtr_SET_userData(PxSceneDescPtr cls, void* value) {cls->userData = value;}

ES PxU32 PxSceneDescPtr_GET_solverBatchSize(PxSceneDescPtr cls) {return (PxU32)cls->solverBatchSize;}
ES void PxSceneDescPtr_SET_solverBatchSize(PxSceneDescPtr cls, PxU32 value) {cls->solverBatchSize = value;}

ES PxU32 PxSceneDescPtr_GET_nbContactDataBlocks(PxSceneDescPtr cls) {return (PxU32)cls->nbContactDataBlocks;}
ES void PxSceneDescPtr_SET_nbContactDataBlocks(PxSceneDescPtr cls, PxU32 value) {cls->nbContactDataBlocks = value;}

ES PxU32 PxSceneDescPtr_GET_maxNbContactDataBlocks(PxSceneDescPtr cls) {return (PxU32)cls->maxNbContactDataBlocks;}
ES void PxSceneDescPtr_SET_maxNbContactDataBlocks(PxSceneDescPtr cls, PxU32 value) {cls->maxNbContactDataBlocks = value;}

ES PxReal PxSceneDescPtr_GET_maxBiasCoefficient(PxSceneDescPtr cls) {return (PxReal)cls->maxBiasCoefficient;}
ES void PxSceneDescPtr_SET_maxBiasCoefficient(PxSceneDescPtr cls, PxReal value) {cls->maxBiasCoefficient = value;}

ES PxU32 PxSceneDescPtr_GET_contactReportStreamBufferSize(PxSceneDescPtr cls) {return (PxU32)cls->contactReportStreamBufferSize;}
ES void PxSceneDescPtr_SET_contactReportStreamBufferSize(PxSceneDescPtr cls, PxU32 value) {cls->contactReportStreamBufferSize = value;}

ES PxU32 PxSceneDescPtr_GET_ccdMaxPasses(PxSceneDescPtr cls) {return (PxU32)cls->ccdMaxPasses;}
ES void PxSceneDescPtr_SET_ccdMaxPasses(PxSceneDescPtr cls, PxU32 value) {cls->ccdMaxPasses = value;}

ES PxReal PxSceneDescPtr_GET_wakeCounterResetValue(PxSceneDescPtr cls) {return (PxReal)cls->wakeCounterResetValue;}
ES void PxSceneDescPtr_SET_wakeCounterResetValue(PxSceneDescPtr cls, PxReal value) {cls->wakeCounterResetValue = value;}

ES void PxSceneDescPtr_GET_sanityBounds(PxSceneDescPtr cls, physx::PxBounds3* GetRetRef) {*GetRetRef = cls->sanityBounds;}
ES void PxSceneDescPtr_SET_sanityBounds(PxSceneDescPtr cls, physx::PxBounds3 value) {cls->sanityBounds = value;}

ES PxgDynamicsMemoryConfigPtr PxSceneDescPtr_GET_gpuDynamicsConfig(PxSceneDescPtr cls) {return (PxgDynamicsMemoryConfigPtr)&cls->gpuDynamicsConfig;}
ES void PxSceneDescPtr_SET_gpuDynamicsConfig(PxSceneDescPtr cls, PxgDynamicsMemoryConfigPtr value) {cls->gpuDynamicsConfig = *value;}

ES PxU32 PxSceneDescPtr_GET_gpuMaxNumPartitions(PxSceneDescPtr cls) {return (PxU32)cls->gpuMaxNumPartitions;}
ES void PxSceneDescPtr_SET_gpuMaxNumPartitions(PxSceneDescPtr cls, PxU32 value) {cls->gpuMaxNumPartitions = value;}

ES PxU32 PxSceneDescPtr_GET_gpuComputeVersion(PxSceneDescPtr cls) {return (PxU32)cls->gpuComputeVersion;}
ES void PxSceneDescPtr_SET_gpuComputeVersion(PxSceneDescPtr cls, PxU32 value) {cls->gpuComputeVersion = value;}

ES void void_PxSceneDescPtr_setToDefaultPtr_PxTolerancesScale_(PxSceneDescPtr wrp_this, physx::PxTolerancesScale* wrp_scale){
    wrp_this->setToDefault(*wrp_scale);
}

ES bool bool_const_PxSceneDescPtr_isValidPtr(PxSceneDescPtr wrp_this){
    return (bool) wrp_this->isValid();
}

ES physx::PxTolerancesScale* PxTolerancesScale_const_PxSceneDescPtr_getTolerancesScalePtr(PxSceneDescPtr wrp_this){
    return (physx::PxTolerancesScale*) &wrp_this->getTolerancesScale();
}

