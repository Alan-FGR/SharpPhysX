// Generated by minBND 5.1.91.1 - Â© github.com/Alan-FGR

ES PxHitFlagsPtr PxHitFlagsPtr_operator_Ptr_Pipe_PxHitFlagEnum_PxHitFlagEnum_(physx::PxHitFlag::Enum wrp_a, physx::PxHitFlag::Enum wrp_b){
    auto ret = ::physx::operator|(wrp_a, wrp_b);
    auto heap = new char[sizeof PxHitFlags];
    std::memcpy(heap, &ret, sizeof PxHitFlags);
    return (PxHitFlagsPtr) heap;
}

ES PxHitFlagsPtr PxHitFlagsPtr_operator_Ptr_Amp_PxHitFlagEnum_PxHitFlagEnum_(physx::PxHitFlag::Enum wrp_a, physx::PxHitFlag::Enum wrp_b){
    auto ret = ::physx::operator&(wrp_a, wrp_b);
    auto heap = new char[sizeof PxHitFlags];
    std::memcpy(heap, &ret, sizeof PxHitFlags);
    return (PxHitFlagsPtr) heap;
}

ES PxHitFlagsPtr PxHitFlagsPtr_operator_Ptr_Tilde_PxHitFlagEnum_(physx::PxHitFlag::Enum wrp_a){
    auto ret = ::physx::operator~(wrp_a);
    auto heap = new char[sizeof PxHitFlags];
    std::memcpy(heap, &ret, sizeof PxHitFlags);
    return (PxHitFlagsPtr) heap;
}

ES PxRaycastHitPtr PxRaycastCallbackPtr_GET_block(PxRaycastCallbackPtr cls) {return (PxRaycastHitPtr)&cls->block;}
ES void PxRaycastCallbackPtr_SET_block(PxRaycastCallbackPtr cls, PxRaycastHitPtr value) {cls->block = *value;}

ES bool PxRaycastCallbackPtr_GET_hasBlock(PxRaycastCallbackPtr cls) {return (bool)cls->hasBlock;}
ES void PxRaycastCallbackPtr_SET_hasBlock(PxRaycastCallbackPtr cls, bool value) {cls->hasBlock = value;}

ES PxRaycastHitPtr PxRaycastCallbackPtr_GET_touches(PxRaycastCallbackPtr cls) {return (PxRaycastHitPtr)cls->touches;}
ES void PxRaycastCallbackPtr_SET_touches(PxRaycastCallbackPtr cls, PxRaycastHitPtr value) {cls->touches = value;}

ES PxU32 PxRaycastCallbackPtr_GET_maxNbTouches(PxRaycastCallbackPtr cls) {return (PxU32)cls->maxNbTouches;}
ES void PxRaycastCallbackPtr_SET_maxNbTouches(PxRaycastCallbackPtr cls, PxU32 value) {cls->maxNbTouches = value;}

ES PxU32 PxRaycastCallbackPtr_GET_nbTouches(PxRaycastCallbackPtr cls) {return (PxU32)cls->nbTouches;}
ES void PxRaycastCallbackPtr_SET_nbTouches(PxRaycastCallbackPtr cls, PxU32 value) {cls->nbTouches = value;}

ES PxAgain bool_PxRaycastCallbackPtr_processTouchesPtr_PxRaycastHitPtr_uint_(PxRaycastCallbackPtr wrp_this, PxRaycastHitPtr wrp_buffer, PxU32 wrp_nbHits){
    return (PxAgain) wrp_this->processTouches(wrp_buffer, wrp_nbHits);
}

ES void void_PxRaycastCallbackPtr_finalizeQueryPtr(PxRaycastCallbackPtr wrp_this){
    wrp_this->finalizeQuery();
}

ES bool bool_PxRaycastCallbackPtr_hasAnyHitsPtr(PxRaycastCallbackPtr wrp_this){
    return (bool) wrp_this->hasAnyHits();
}

ES PxSweepHitPtr PxSweepCallbackPtr_GET_block(PxSweepCallbackPtr cls) {return (PxSweepHitPtr)&cls->block;}
ES void PxSweepCallbackPtr_SET_block(PxSweepCallbackPtr cls, PxSweepHitPtr value) {cls->block = *value;}

ES bool PxSweepCallbackPtr_GET_hasBlock(PxSweepCallbackPtr cls) {return (bool)cls->hasBlock;}
ES void PxSweepCallbackPtr_SET_hasBlock(PxSweepCallbackPtr cls, bool value) {cls->hasBlock = value;}

ES PxSweepHitPtr PxSweepCallbackPtr_GET_touches(PxSweepCallbackPtr cls) {return (PxSweepHitPtr)cls->touches;}
ES void PxSweepCallbackPtr_SET_touches(PxSweepCallbackPtr cls, PxSweepHitPtr value) {cls->touches = value;}

ES PxU32 PxSweepCallbackPtr_GET_maxNbTouches(PxSweepCallbackPtr cls) {return (PxU32)cls->maxNbTouches;}
ES void PxSweepCallbackPtr_SET_maxNbTouches(PxSweepCallbackPtr cls, PxU32 value) {cls->maxNbTouches = value;}

ES PxU32 PxSweepCallbackPtr_GET_nbTouches(PxSweepCallbackPtr cls) {return (PxU32)cls->nbTouches;}
ES void PxSweepCallbackPtr_SET_nbTouches(PxSweepCallbackPtr cls, PxU32 value) {cls->nbTouches = value;}

ES PxAgain bool_PxSweepCallbackPtr_processTouchesPtr_PxSweepHitPtr_uint_(PxSweepCallbackPtr wrp_this, PxSweepHitPtr wrp_buffer, PxU32 wrp_nbHits){
    return (PxAgain) wrp_this->processTouches(wrp_buffer, wrp_nbHits);
}

ES void void_PxSweepCallbackPtr_finalizeQueryPtr(PxSweepCallbackPtr wrp_this){
    wrp_this->finalizeQuery();
}

ES bool bool_PxSweepCallbackPtr_hasAnyHitsPtr(PxSweepCallbackPtr wrp_this){
    return (bool) wrp_this->hasAnyHits();
}

ES PxOverlapHitPtr PxOverlapCallbackPtr_GET_block(PxOverlapCallbackPtr cls) {return (PxOverlapHitPtr)&cls->block;}
ES void PxOverlapCallbackPtr_SET_block(PxOverlapCallbackPtr cls, PxOverlapHitPtr value) {cls->block = *value;}

ES bool PxOverlapCallbackPtr_GET_hasBlock(PxOverlapCallbackPtr cls) {return (bool)cls->hasBlock;}
ES void PxOverlapCallbackPtr_SET_hasBlock(PxOverlapCallbackPtr cls, bool value) {cls->hasBlock = value;}

ES PxOverlapHitPtr PxOverlapCallbackPtr_GET_touches(PxOverlapCallbackPtr cls) {return (PxOverlapHitPtr)cls->touches;}
ES void PxOverlapCallbackPtr_SET_touches(PxOverlapCallbackPtr cls, PxOverlapHitPtr value) {cls->touches = value;}

ES PxU32 PxOverlapCallbackPtr_GET_maxNbTouches(PxOverlapCallbackPtr cls) {return (PxU32)cls->maxNbTouches;}
ES void PxOverlapCallbackPtr_SET_maxNbTouches(PxOverlapCallbackPtr cls, PxU32 value) {cls->maxNbTouches = value;}

ES PxU32 PxOverlapCallbackPtr_GET_nbTouches(PxOverlapCallbackPtr cls) {return (PxU32)cls->nbTouches;}
ES void PxOverlapCallbackPtr_SET_nbTouches(PxOverlapCallbackPtr cls, PxU32 value) {cls->nbTouches = value;}

ES PxAgain bool_PxOverlapCallbackPtr_processTouchesPtr_PxOverlapHitPtr_uint_(PxOverlapCallbackPtr wrp_this, PxOverlapHitPtr wrp_buffer, PxU32 wrp_nbHits){
    return (PxAgain) wrp_this->processTouches(wrp_buffer, wrp_nbHits);
}

ES void void_PxOverlapCallbackPtr_finalizeQueryPtr(PxOverlapCallbackPtr wrp_this){
    wrp_this->finalizeQuery();
}

ES bool bool_PxOverlapCallbackPtr_hasAnyHitsPtr(PxOverlapCallbackPtr wrp_this){
    return (bool) wrp_this->hasAnyHits();
}

ES void Freer_physx_PxRaycastBufferPtr(PxRaycastBufferPtr ptr){
    delete ptr;
}

ES PxRaycastBufferPtr Ctor_PxRaycastBufferPtr_PxRaycastHitPtr_uint(PxRaycastHitPtr wrp_aTouches, PxU32 wrp_aMaxNbTouches){
    auto ret = *(new std::remove_pointer<PxRaycastBufferPtr>::type(wrp_aTouches, wrp_aMaxNbTouches));
    auto heap = new char[sizeof PxRaycastBuffer];
    std::memcpy(heap, &ret, sizeof PxRaycastBuffer);
    return (PxRaycastBufferPtr) heap;
}

ES PxRaycastBufferPtr Ctor_PxRaycastBufferPtr_(){
    auto ret = *(new std::remove_pointer<PxRaycastBufferPtr>::type());
    auto heap = new char[sizeof PxRaycastBuffer];
    std::memcpy(heap, &ret, sizeof PxRaycastBuffer);
    return (PxRaycastBufferPtr) heap;
}

ES PxRaycastBufferPtr Ctor_PxRaycastBufferPtr_PxRaycastHitPtr(PxRaycastHitPtr wrp_aTouches){
    auto ret = *(new std::remove_pointer<PxRaycastBufferPtr>::type(wrp_aTouches));
    auto heap = new char[sizeof PxRaycastBuffer];
    std::memcpy(heap, &ret, sizeof PxRaycastBuffer);
    return (PxRaycastBufferPtr) heap;
}

ES PxU32 uint_const_PxRaycastBufferPtr_getNbAnyHitsPtr(PxRaycastBufferPtr wrp_this){
    return (PxU32) wrp_this->getNbAnyHits();
}

ES PxRaycastHitPtr PxRaycastHitPtr_const_PxRaycastBufferPtr_getAnyHitPtr_uintC(PxRaycastBufferPtr wrp_this, PxU32 wrp_index){
    return (PxRaycastHitPtr) &wrp_this->getAnyHit(wrp_index);
}

ES PxU32 uint_const_PxRaycastBufferPtr_getNbTouchesPtr(PxRaycastBufferPtr wrp_this){
    return (PxU32) wrp_this->getNbTouches();
}

ES PxRaycastHitPtr PxRaycastHitPtr_const_PxRaycastBufferPtr_getTouchesPtr(PxRaycastBufferPtr wrp_this){
    return (PxRaycastHitPtr) wrp_this->getTouches();
}

ES PxRaycastHitPtr PxRaycastHitPtr_const_PxRaycastBufferPtr_getTouchPtr_uintC(PxRaycastBufferPtr wrp_this, PxU32 wrp_index){
    return (PxRaycastHitPtr) &wrp_this->getTouch(wrp_index);
}

ES PxU32 uint_const_PxRaycastBufferPtr_getMaxNbTouchesPtr(PxRaycastBufferPtr wrp_this){
    return (PxU32) wrp_this->getMaxNbTouches();
}

ES void Freer_physx_PxOverlapBufferPtr(PxOverlapBufferPtr ptr){
    delete ptr;
}

ES PxOverlapBufferPtr Ctor_PxOverlapBufferPtr_PxOverlapHitPtr_uint(PxOverlapHitPtr wrp_aTouches, PxU32 wrp_aMaxNbTouches){
    auto ret = *(new std::remove_pointer<PxOverlapBufferPtr>::type(wrp_aTouches, wrp_aMaxNbTouches));
    auto heap = new char[sizeof PxOverlapBuffer];
    std::memcpy(heap, &ret, sizeof PxOverlapBuffer);
    return (PxOverlapBufferPtr) heap;
}

ES PxOverlapBufferPtr Ctor_PxOverlapBufferPtr_(){
    auto ret = *(new std::remove_pointer<PxOverlapBufferPtr>::type());
    auto heap = new char[sizeof PxOverlapBuffer];
    std::memcpy(heap, &ret, sizeof PxOverlapBuffer);
    return (PxOverlapBufferPtr) heap;
}

ES PxOverlapBufferPtr Ctor_PxOverlapBufferPtr_PxOverlapHitPtr(PxOverlapHitPtr wrp_aTouches){
    auto ret = *(new std::remove_pointer<PxOverlapBufferPtr>::type(wrp_aTouches));
    auto heap = new char[sizeof PxOverlapBuffer];
    std::memcpy(heap, &ret, sizeof PxOverlapBuffer);
    return (PxOverlapBufferPtr) heap;
}

ES PxU32 uint_const_PxOverlapBufferPtr_getNbAnyHitsPtr(PxOverlapBufferPtr wrp_this){
    return (PxU32) wrp_this->getNbAnyHits();
}

ES PxOverlapHitPtr PxOverlapHitPtr_const_PxOverlapBufferPtr_getAnyHitPtr_uintC(PxOverlapBufferPtr wrp_this, PxU32 wrp_index){
    return (PxOverlapHitPtr) &wrp_this->getAnyHit(wrp_index);
}

ES PxU32 uint_const_PxOverlapBufferPtr_getNbTouchesPtr(PxOverlapBufferPtr wrp_this){
    return (PxU32) wrp_this->getNbTouches();
}

ES PxOverlapHitPtr PxOverlapHitPtr_const_PxOverlapBufferPtr_getTouchesPtr(PxOverlapBufferPtr wrp_this){
    return (PxOverlapHitPtr) wrp_this->getTouches();
}

ES PxOverlapHitPtr PxOverlapHitPtr_const_PxOverlapBufferPtr_getTouchPtr_uintC(PxOverlapBufferPtr wrp_this, PxU32 wrp_index){
    return (PxOverlapHitPtr) &wrp_this->getTouch(wrp_index);
}

ES PxU32 uint_const_PxOverlapBufferPtr_getMaxNbTouchesPtr(PxOverlapBufferPtr wrp_this){
    return (PxU32) wrp_this->getMaxNbTouches();
}

ES void Freer_physx_PxSweepBufferPtr(PxSweepBufferPtr ptr){
    delete ptr;
}

ES PxSweepBufferPtr Ctor_PxSweepBufferPtr_PxSweepHitPtr_uint(PxSweepHitPtr wrp_aTouches, PxU32 wrp_aMaxNbTouches){
    auto ret = *(new std::remove_pointer<PxSweepBufferPtr>::type(wrp_aTouches, wrp_aMaxNbTouches));
    auto heap = new char[sizeof PxSweepBuffer];
    std::memcpy(heap, &ret, sizeof PxSweepBuffer);
    return (PxSweepBufferPtr) heap;
}

ES PxSweepBufferPtr Ctor_PxSweepBufferPtr_(){
    auto ret = *(new std::remove_pointer<PxSweepBufferPtr>::type());
    auto heap = new char[sizeof PxSweepBuffer];
    std::memcpy(heap, &ret, sizeof PxSweepBuffer);
    return (PxSweepBufferPtr) heap;
}

ES PxSweepBufferPtr Ctor_PxSweepBufferPtr_PxSweepHitPtr(PxSweepHitPtr wrp_aTouches){
    auto ret = *(new std::remove_pointer<PxSweepBufferPtr>::type(wrp_aTouches));
    auto heap = new char[sizeof PxSweepBuffer];
    std::memcpy(heap, &ret, sizeof PxSweepBuffer);
    return (PxSweepBufferPtr) heap;
}

ES PxU32 uint_const_PxSweepBufferPtr_getNbAnyHitsPtr(PxSweepBufferPtr wrp_this){
    return (PxU32) wrp_this->getNbAnyHits();
}

ES PxSweepHitPtr PxSweepHitPtr_const_PxSweepBufferPtr_getAnyHitPtr_uintC(PxSweepBufferPtr wrp_this, PxU32 wrp_index){
    return (PxSweepHitPtr) &wrp_this->getAnyHit(wrp_index);
}

ES PxU32 uint_const_PxSweepBufferPtr_getNbTouchesPtr(PxSweepBufferPtr wrp_this){
    return (PxU32) wrp_this->getNbTouches();
}

ES PxSweepHitPtr PxSweepHitPtr_const_PxSweepBufferPtr_getTouchesPtr(PxSweepBufferPtr wrp_this){
    return (PxSweepHitPtr) wrp_this->getTouches();
}

ES PxSweepHitPtr PxSweepHitPtr_const_PxSweepBufferPtr_getTouchPtr_uintC(PxSweepBufferPtr wrp_this, PxU32 wrp_index){
    return (PxSweepHitPtr) &wrp_this->getTouch(wrp_index);
}

ES PxU32 uint_const_PxSweepBufferPtr_getMaxNbTouchesPtr(PxSweepBufferPtr wrp_this){
    return (PxU32) wrp_this->getMaxNbTouches();
}

ES void Freer_physx_PxActorShapePtr(PxActorShapePtr ptr){
    delete ptr;
}

ES PxActorShapePtr Ctor_PxActorShapePtr_(){
    auto ret = *(new std::remove_pointer<PxActorShapePtr>::type());
    auto heap = new char[sizeof PxActorShape];
    std::memcpy(heap, &ret, sizeof PxActorShape);
    return (PxActorShapePtr) heap;
}

ES PxActorShapePtr Ctor_PxActorShapePtr_PxRigidActorPtr_PxShapePtr(PxRigidActorPtr wrp_a, PxShapePtr wrp_s){
    auto ret = *(new std::remove_pointer<PxActorShapePtr>::type(wrp_a, wrp_s));
    auto heap = new char[sizeof PxActorShape];
    std::memcpy(heap, &ret, sizeof PxActorShape);
    return (PxActorShapePtr) heap;
}

ES PxRigidActorPtr PxActorShapePtr_GET_actor(PxActorShapePtr cls) {return (PxRigidActorPtr)cls->actor;}
ES void PxActorShapePtr_SET_actor(PxActorShapePtr cls, PxRigidActorPtr value) {cls->actor = value;}

ES PxShapePtr PxActorShapePtr_GET_shape(PxActorShapePtr cls) {return (PxShapePtr)cls->shape;}
ES void PxActorShapePtr_SET_shape(PxActorShapePtr cls, PxShapePtr value) {cls->shape = value;}

ES void Freer_physx_PxQueryHitPtr(PxQueryHitPtr ptr){
    delete ptr;
}

ES PxQueryHitPtr Ctor_PxQueryHitPtr_(){
    auto ret = *(new std::remove_pointer<PxQueryHitPtr>::type());
    auto heap = new char[sizeof PxQueryHit];
    std::memcpy(heap, &ret, sizeof PxQueryHit);
    return (PxQueryHitPtr) heap;
}

ES PxU32 PxQueryHitPtr_GET_faceIndex(PxQueryHitPtr cls) {return (PxU32)cls->faceIndex;}
ES void PxQueryHitPtr_SET_faceIndex(PxQueryHitPtr cls, PxU32 value) {cls->faceIndex = value;}

ES void Freer_physx_PxLocationHitPtr(PxLocationHitPtr ptr){
    delete ptr;
}

ES PxLocationHitPtr Ctor_PxLocationHitPtr_(){
    auto ret = *(new std::remove_pointer<PxLocationHitPtr>::type());
    auto heap = new char[sizeof PxLocationHit];
    std::memcpy(heap, &ret, sizeof PxLocationHit);
    return (PxLocationHitPtr) heap;
}

ES PxHitFlagsPtr PxLocationHitPtr_GET_flags(PxLocationHitPtr cls) {return (PxHitFlagsPtr)&cls->flags;}
ES void PxLocationHitPtr_SET_flags(PxLocationHitPtr cls, PxHitFlagsPtr value) {cls->flags = *value;}

ES void PxLocationHitPtr_GET_position(PxLocationHitPtr cls, physx::PxVec3* GetRetRef) {*GetRetRef = cls->position;}
ES void PxLocationHitPtr_SET_position(PxLocationHitPtr cls, physx::PxVec3 value) {cls->position = value;}

ES void PxLocationHitPtr_GET_normal(PxLocationHitPtr cls, physx::PxVec3* GetRetRef) {*GetRetRef = cls->normal;}
ES void PxLocationHitPtr_SET_normal(PxLocationHitPtr cls, physx::PxVec3 value) {cls->normal = value;}

ES PxF32 PxLocationHitPtr_GET_distance(PxLocationHitPtr cls) {return (PxF32)cls->distance;}
ES void PxLocationHitPtr_SET_distance(PxLocationHitPtr cls, PxF32 value) {cls->distance = value;}

ES bool bool_const_PxLocationHitPtr_hadInitialOverlapPtr(PxLocationHitPtr wrp_this){
    return (bool) wrp_this->hadInitialOverlap();
}

ES void Freer_physx_PxRaycastHitPtr(PxRaycastHitPtr ptr){
    delete ptr;
}

ES PxRaycastHitPtr Ctor_PxRaycastHitPtr_(){
    auto ret = *(new std::remove_pointer<PxRaycastHitPtr>::type());
    auto heap = new char[sizeof PxRaycastHit];
    std::memcpy(heap, &ret, sizeof PxRaycastHit);
    return (PxRaycastHitPtr) heap;
}

ES PxReal PxRaycastHitPtr_GET_u(PxRaycastHitPtr cls) {return (PxReal)cls->u;}
ES void PxRaycastHitPtr_SET_u(PxRaycastHitPtr cls, PxReal value) {cls->u = value;}

ES PxReal PxRaycastHitPtr_GET_v(PxRaycastHitPtr cls) {return (PxReal)cls->v;}
ES void PxRaycastHitPtr_SET_v(PxRaycastHitPtr cls, PxReal value) {cls->v = value;}

ES PxOverlapHitPtr Newer_physx_PxOverlapHitPtr(){
    return new std::remove_pointer<PxOverlapHitPtr>::type();
}
ES void Freer_physx_PxOverlapHitPtr(PxOverlapHitPtr ptr){
    delete ptr;
}

ES PxU32 PxOverlapHitPtr_GET_padTo16Bytes(PxOverlapHitPtr cls) {return (PxU32)cls->padTo16Bytes;}
ES void PxOverlapHitPtr_SET_padTo16Bytes(PxOverlapHitPtr cls, PxU32 value) {cls->padTo16Bytes = value;}

ES void Freer_physx_PxSweepHitPtr(PxSweepHitPtr ptr){
    delete ptr;
}

ES PxSweepHitPtr Ctor_PxSweepHitPtr_(){
    auto ret = *(new std::remove_pointer<PxSweepHitPtr>::type());
    auto heap = new char[sizeof PxSweepHit];
    std::memcpy(heap, &ret, sizeof PxSweepHit);
    return (PxSweepHitPtr) heap;
}

ES PxU32 PxSweepHitPtr_GET_padTo16Bytes(PxSweepHitPtr cls) {return (PxU32)cls->padTo16Bytes;}
ES void PxSweepHitPtr_SET_padTo16Bytes(PxSweepHitPtr cls, PxU32 value) {cls->padTo16Bytes = value;}

