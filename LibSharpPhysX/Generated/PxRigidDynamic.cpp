// Generated by minBND 5.1.91.1 - Â© github.com/Alan-FGR

ES PxRigidDynamicLockFlagsPtr PxRigidDynamicLockFlagsPtr_operator_Ptr_Pipe_PxRigidDynamicLockFlagEnum_PxRigidDynamicLockFlagEnum_(physx::PxRigidDynamicLockFlag::Enum wrp_a, physx::PxRigidDynamicLockFlag::Enum wrp_b){
    auto ret = ::physx::operator|(wrp_a, wrp_b);
    auto heap = new char[sizeof PxRigidDynamicLockFlags];
    std::memcpy(heap, &ret, sizeof PxRigidDynamicLockFlags);
    return (PxRigidDynamicLockFlagsPtr) heap;
}

ES PxRigidDynamicLockFlagsPtr PxRigidDynamicLockFlagsPtr_operator_Ptr_Amp_PxRigidDynamicLockFlagEnum_PxRigidDynamicLockFlagEnum_(physx::PxRigidDynamicLockFlag::Enum wrp_a, physx::PxRigidDynamicLockFlag::Enum wrp_b){
    auto ret = ::physx::operator&(wrp_a, wrp_b);
    auto heap = new char[sizeof PxRigidDynamicLockFlags];
    std::memcpy(heap, &ret, sizeof PxRigidDynamicLockFlags);
    return (PxRigidDynamicLockFlagsPtr) heap;
}

ES PxRigidDynamicLockFlagsPtr PxRigidDynamicLockFlagsPtr_operator_Ptr_Tilde_PxRigidDynamicLockFlagEnum_(physx::PxRigidDynamicLockFlag::Enum wrp_a){
    auto ret = ::physx::operator~(wrp_a);
    auto heap = new char[sizeof PxRigidDynamicLockFlags];
    std::memcpy(heap, &ret, sizeof PxRigidDynamicLockFlags);
    return (PxRigidDynamicLockFlagsPtr) heap;
}

ES void void_PxRigidDynamicPtr_setKinematicTargetPtr_PxTransform_(PxRigidDynamicPtr wrp_this, physx::PxTransform* wrp_destination){
    wrp_this->setKinematicTarget(*wrp_destination);
}

ES bool bool_const_PxRigidDynamicPtr_getKinematicTargetPtr_PxTransform_(PxRigidDynamicPtr wrp_this, physx::PxTransform* wrp_target){
    return (bool) wrp_this->getKinematicTarget(*wrp_target);
}

ES bool bool_const_PxRigidDynamicPtr_isSleepingPtr(PxRigidDynamicPtr wrp_this){
    return (bool) wrp_this->isSleeping();
}

ES void void_PxRigidDynamicPtr_setSleepThresholdPtr_float_(PxRigidDynamicPtr wrp_this, PxReal wrp_threshold){
    wrp_this->setSleepThreshold(wrp_threshold);
}

ES PxReal float_const_PxRigidDynamicPtr_getSleepThresholdPtr(PxRigidDynamicPtr wrp_this){
    return (PxReal) wrp_this->getSleepThreshold();
}

ES void void_PxRigidDynamicPtr_setStabilizationThresholdPtr_float_(PxRigidDynamicPtr wrp_this, PxReal wrp_threshold){
    wrp_this->setStabilizationThreshold(wrp_threshold);
}

ES PxReal float_const_PxRigidDynamicPtr_getStabilizationThresholdPtr(PxRigidDynamicPtr wrp_this){
    return (PxReal) wrp_this->getStabilizationThreshold();
}

ES PxRigidDynamicLockFlagsPtr PxRigidDynamicLockFlagsPtr_const_PxRigidDynamicPtr_getRigidDynamicLockFlagsPtr(PxRigidDynamicPtr wrp_this){
    auto ret = wrp_this->getRigidDynamicLockFlags();
    auto heap = new char[sizeof PxRigidDynamicLockFlags];
    std::memcpy(heap, &ret, sizeof PxRigidDynamicLockFlags);
    return (PxRigidDynamicLockFlagsPtr) heap;
}

ES void void_PxRigidDynamicPtr_setRigidDynamicLockFlagPtr_PxRigidDynamicLockFlagEnum_bool_(PxRigidDynamicPtr wrp_this, physx::PxRigidDynamicLockFlag::Enum wrp_flag, bool wrp_value){
    wrp_this->setRigidDynamicLockFlag(wrp_flag, wrp_value);
}

ES void void_PxRigidDynamicPtr_setRigidDynamicLockFlagsPtr_PxRigidDynamicLockFlagsPtr_(PxRigidDynamicPtr wrp_this, PxRigidDynamicLockFlagsPtr wrp_flags){
    wrp_this->setRigidDynamicLockFlags(*wrp_flags);
}

ES void void_PxRigidDynamicPtr_setWakeCounterPtr_float_(PxRigidDynamicPtr wrp_this, PxReal wrp_wakeCounterValue){
    wrp_this->setWakeCounter(wrp_wakeCounterValue);
}

ES PxReal float_const_PxRigidDynamicPtr_getWakeCounterPtr(PxRigidDynamicPtr wrp_this){
    return (PxReal) wrp_this->getWakeCounter();
}

ES void void_PxRigidDynamicPtr_wakeUpPtr(PxRigidDynamicPtr wrp_this){
    wrp_this->wakeUp();
}

ES void void_PxRigidDynamicPtr_putToSleepPtr(PxRigidDynamicPtr wrp_this){
    wrp_this->putToSleep();
}

ES void void_PxRigidDynamicPtr_setSolverIterationCountsPtr_uint_uint_(PxRigidDynamicPtr wrp_this, PxU32 wrp_minPositionIters, PxU32 wrp_minVelocityIters){
    wrp_this->setSolverIterationCounts(wrp_minPositionIters, wrp_minVelocityIters);
}

ES void void_const_PxRigidDynamicPtr_getSolverIterationCountsPtr_uint_uint_(PxRigidDynamicPtr wrp_this, PxU32* wrp_minPositionIters, PxU32* wrp_minVelocityIters){
    wrp_this->getSolverIterationCounts(*wrp_minPositionIters, *wrp_minVelocityIters);
}

ES PxReal float_const_PxRigidDynamicPtr_getContactReportThresholdPtr(PxRigidDynamicPtr wrp_this){
    return (PxReal) wrp_this->getContactReportThreshold();
}

ES void void_PxRigidDynamicPtr_setContactReportThresholdPtr_float_(PxRigidDynamicPtr wrp_this, PxReal wrp_threshold){
    wrp_this->setContactReportThreshold(wrp_threshold);
}

ES char* string_const_PxRigidDynamicPtr_getConcreteTypeNamePtr(PxRigidDynamicPtr wrp_this){
    return (char*) wrp_this->getConcreteTypeName();
}

ES void void_PxRigidDynamicPtr_setSolverIterationCountsPtr_uint_(PxRigidDynamicPtr wrp_this, PxU32 wrp_minPositionIters){
    wrp_this->setSolverIterationCounts(wrp_minPositionIters);
}

